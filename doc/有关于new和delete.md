# 有关于 new 和 delete
## new 的一般用法
### 创建与删除一般变量
#### 使用 new 来创建
```c++
Type* variable = new Type;
```
**解释** ：该语句分为两部分来理解
- 等号后面的部分，是程序**运行时**在堆上执行的内存分配动作。在看到 new 之后表明接下来要去堆上分配合适的内存，Type 参数告诉了内存分配器本次的内存请求需要多大的内存，然后 new 会根据这个参数来找到合适的内存块，并且返回这个未命名内存块的起始地址。**此后对这个未命名的内存，仅能通过这个地址来访问。**
- 等号前面的部分，是程序员需要负责的部分。用于记录保存 new 返回的未命名内存地址值，并且需要为这个指针变量指定类型，通过这种指定，在此后使用该指针变量的时候才知道应该取多大的内存来解析值。

所以一个完整语句产生的效果就是：**分配了一块可以存放 Type 类型变量值的内存，并且后续仅能通过 variable 这个变量来访问这个内存地址。**
#### 使用 delete 来释放内存地址
```c++
delete variable;
```
使用 delete 指令可以释放掉之前由 new 分配的内存，不过仅仅是释放掉内存，variable 变量的值仍然存在，并且该变量还可以继续用于保存同类型的别的指针。释放掉的内存可以被别的过程重新使用，所以一个完整的释放过程应该如下：
```c++
delete variable;
variable = nullptr;
```
不过如果在 delete 之后确定是不会再使用到了 variable 变量，也可以省略第二步，比如在程序结束前 delete 一个 new 对象，就可以不用再指定对应的指针为空指针。（但是对于 new 的是一个对象的情况除外，因为对一个 new 出来的对象指针，如果不调用 delete 显式释放该内存，是不会调用该对象的析构函数的，如果该函数的构造函数里面使用了 new 来分配内存，那么在多线程环境下，某个线程即使退出了，但是由于没有调用析构函数，而导致 new 在堆上面的内存没有被释放掉，会导致内存泄漏。）

**new 和 delete 需要成对出现**，对于一个服务器程序或者是 daemon 进程，由于会长时间驻留在内存中，如果不合理管理内存，没有及时释放掉没有使用的内存空间，会导致内存泄露。而且 c++ 还规定了，对一个已经释放的内存地址再次释放，这个行为的结果是未定义的，即什么情况都会发生，当出现这种情况的时候一般运行时都会直接抛出 double free 错误，并且产生核心转储文件。有一种情况下会不经意导致 double free 错误的发生：
```c++
int* int_ptr = new int;
int* record_ptr = int_ptr;
delete int_ptr;
delete record_ptr;  // !!! double free !!!
```
上述的代码中，int_ptr 和 record_ptr 其实指向的是同一个内存块，所以当对两个分别 delete 的时候是会导致 double free 的。
### 创建与删除数组
#### 用 new 来创建动态数组
```c++
Type* arr_variable = new Type [arr_number];
```
**解释** ：用 new 来声明数组的时候，与一般类型声明的区别在于最后会使用方括号 [] 来指定声明的数组元素数量。返回的是该数组第一个元素的地址。

有一点需要注意，用这种方法得到的数组是一个**未命名数组**，我们只是通过一个指针来保存了这个数组的第一个元素地址，并以这个地址为基址来找到别的数组元素。我们知道数组名是不能被修改的（只读），即：
```c++
Type arr_name[arr_number];
```
用上述方法得到的是命名数组，其数组名为 arr_name ，是一个常量，不能对其进行算术操作，仅能通过运算符 **"[]"** 来获取数组元素。但是对于使用 new 来得到的数组，是通过指向其首元素的指针来管理的，而指针是可以进行运算的，所以当 *arr_variable++;* 之后，arr_variable[0] 指向的就是第二个元素了。如果在这种情况下通过 delete 去释放 new 出来的数组空间是会出错的。

还有个小问题就是关于动态数组的初始化。如果按照上述所讲的基本步骤去操作生成一个动态数组，数组元素都是**没有被初始化的**。
- 对于内置类型而言，可以通过在 [] 符号后面加上 () 来显式调用 0 初始化过程。对于单个元素的 new 操作，可以初始化为非 0 元素，但是对于动态数组，是没有办法将所有元素都初始化为非 0 元素的。
  ```c++
  int* a = new int;             //未初始化
  int* b = new int();           //初始化为 0 ，*b = 0;
  int* c = new int(0);          //指定初始化为 0 ，*c = 0;
  int* d = new int(7);          //指定初始化为 7 ，*d = 7;
  int* arr_e = new int [5];     //未初始化
  int* arr_f = new int [5]();   //数组元素都初始化为 0
  int* arr_g = new int [5](0);  //语法错误
  int* arr_h = new int [5](7);  //语法错误
  ```
  不过 c++11 新增了动态数组的初始化列表特性，但是是逐元素进行初始化的，同样不能一次将所有元素都初始化为某个值。
  ```c++
  int* arr_i = new int [8]{4};      //只有 arr_i[0]=4,而 arr_i[1-7]=0
  int* arr_k = new int [8]{4,5,6};  //arr_k[0]=4,arr_k[1]=5,arr_k[2]=6,arr_k[3-7]=0
  ```
- 对于自定义类的动态**数组**，在 new 的时候无论 [] 后面是否跟上 () ，每一个数组元素都会自动调用默认构造函数。对于非数组的情况，请参考[指向对象的指针](#指向对象的指针)

#### 用 delete 释放数组空间
```c++
delete [] arr_name;
```
总之，在使用 delete 的时候应该遵循以下规则：
- 不要使用 delete 来释放不是 new 分配的内存；
- 不要使用 delete 来释放同一个内存地址两次（多次及以上）；
- 如果是使用 new [] 来对一个动态数组分配的内存，释放的时候应该使用 delete [] 来释放。
- 如果使用 new [] 来对一个实体分配内存，释放的时候使用 delete 来释放。
- **对空指针的 delete 是安全的！**

**对于最后一点，更加强调了 delete 一个指针之后为其赋值 nullptr 的正确性。**

## 指向对象的指针
如果一个对象是通过 new 创建的，在创建的时候会调用构造函数，并且只有在显式调用 delete 释放该对象的时候才会调用这个对象的析构函数。而至于会调用哪个构造函数，则具体看传入参数符合哪个构造函数的原型。参考代码 [classtest.cpp](../src/classtest.cpp) 。当 EXPLICIT_DELETE 定义为 0 的时候，打印出来的析构信息只有 5 个（一共产生了 8 个对象，其中有 3 个是 new 出来的）
```c++
class String{
    public:
        String();
        String(const char*);
        String(String &);
    ...
};
int main()
{
    String* a = new String;             //调用默认构造函数
    String* b = new String("louis");    //调用 String(const char*) 构造函数
    String* c = new String(*a);         //调用 String(String &)构造函数
    ...
}
```
## new 定位运算符
```c++
Type* variable = new (location) Type;
Type* arr_variable = new (location) Type[length];
```
定位 new 运算符的编码方式如上所示，除了 location 部分，其余部分与常规的 new 用法是相同的，其中 location 就是指定可以分配的内存块。与常规的 new 操作有所不同的是，常规 new 操作是从内存中找到一个合适大小的内存块，然后返回分配的地址，多次调用，返回的是不同的地址。但是 new 定位运算符会返回相同的地址（如果 location 不改变的话），因为他不负责跟踪记录哪些内存是已使用的，哪些是可分配的，这个工作交给了程序员来完成。

再者就是这些内存空间的释放，首先记住一点，由于定位 new 运算符并没有记录内存的使用情况，所以是没有办法使用 delete 来释放内存的，因为他不知道该怎么释放（释放多大，是否合并等），所以对于 location 内存块，应该是用分配 location 内存的对应释放内存方法来直接释放 location 内存块，而不用管在 location 中定位 new 出来的东西是什么。

默认的 new 定位运算符的工作原理很简单，就是简单的返回传递给他的地址（location），并将其强制转换为 void* 以便于能够再重新赋值给任意类型。但是程序员是可以重载定位 new 运算符的。
### 关于 new 定位运算符的析构
有一个问题是需要注意的，那就是如果使用 new 定位运算符新建了一个对象，新建的时候会自动调用构造函数来初始化对象，但是怎么调用析构函数呢？对于在堆上 new 出来的对象，在显式调用 delete 的时候才会调用析构函数，可是对于 new 定位运算符，并不能对在其上新建的对象调用 delete ，所以程序员在 delete 整个 location 之前应该显式调用该区域上对象的析构函数：
```c++
Classtype *variable = new(location) Classtype;
variable->~Classtype(); //显式调用析构函数
```

---
## 附录-关于指针与数组
### 指针加运算
指针类型是 C 和 C++ 的内置类型，指针也有指针运算。

对一个整型进行加一操作其结果是值加一（不考虑溢出），但是对于一个指针加一，其结果是加上指针指向数据类型所占用的字节数，等同于是从上一个数据对象指向下一个数据对象（连续数据内存）。
### 指针 sizeof 
对一个数组名进行 sizeof ,得到的是数组长度（不是元素个数，而是整个数组所占的字节数），但是如果对指针进行 sizeof 得到的是指针长度（在64位机器上，一个指针的长度总是 8 字节）。
### 数组名的意义
一个数组名是一个常量，这个之前已经有所提及。数组名的内存意义，是数组第一个元素的地址。现有数组如下：
```c++
int my_arr[10];
```
则 my_arr = &(my_arr[0]) ，那么对于数组名取地址意义是什么呢？对一个数组名取地址，实际上得到的是整个数组的地址，从数值上来说，这两个值，my_arr 和 &my_arr 是相等的，但是意义不同，并且做指针运算的结果也不同。对于 my_arr 做指针加运算，加的是一个 int 的长度，即 4 字节，但是如果对 &my_arr 执行指针加运算，加的是 10 个 int 的长度，是整个数组的长度，即 40 个字节。