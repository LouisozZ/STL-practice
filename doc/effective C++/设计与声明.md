# 设计与声明

<!-- TOC -->
- [设计与声明](#设计与声明)
  - [设计类的时候需要思考的事情](#设计类的时候需要思考的事情)
  - [返回值类型](#返回值类型)
  - [将成员变量声明为 private](#将成员变量声明为-private)
  - [成员函数、友元函数还是非成员非友元](#成员函数友元函数还是非成员非友元)
  - [写一个不抛异常的 swap 函数](#写一个不抛异常的-swap-函数)

当设计接口的时候，应该给使用用户一种体验，就是如果我调用你的接口，通过了编译，那么就是我用对了，否则就是接口的使用出错。本着这一种目的去编写接口，得到的就是容易被正确使用的接口，而不是容易被误用的接口。

要实现上述的目标，有以下几种方法：

1. 从正面来努力，促进接口被正确使用，那就需要别写具有一致性的接口，不要这个类取得长度使用的是 size() 接口，另一个类取得长度使用的是 length() 接口；并且需要尽力保证新的类型他的动作能与内置类型的行为兼容。
2. 从反面努力，消除接口的误用：
   - 将参数类型化，也就是创建出对应的新类型，通过类型匹配来检查参数的合法性；
   - 限制某些类型上的操作，比如表示一个独特对象的类，不允许拷贝赋值等，只允许构造；
   - 限制对象的值域，例如月份的取值只能是\[1,12\]。

## 设计类的时候需要思考的事情

当我们设计一个类的时候，应该抱着设计一种内置类型的心态来设计我们的类，需要考虑很多事情，具体的每一项请参考 Effective C++ 第四章的条款19。

## 返回值类型

如果是返回一个非临时自动变量，对于自定义类型来说，通常是返回指针或者引用来的高效，因为避免了产生一个临时变量，并且调用拷贝构造的代价。但是如果返回的对象是在被调用的函数内部声明定义的，这个时候就应该按值传递返回值。因为一个临时的自动变量，当函数返回的时候，也是其析构函数别调用的时候，如果返回的是一个引用或者指针，此时返回值指代的就是一个不存在的对象，会导致未定义的行为。

此外按引用传递还可以避免返回值类型为基类相关，但是实际返回的实参是派生类相关对象的时候出现的截断现象。而且按引用传递，返回的是被传递对象本身，不会出现调用副本的函数的现象。

还有一点需要注意的就是尽量要合理使用 const 限定符。

## 将成员变量声明为 private

c++ 支持用户自定义类型，相较于 c 而言，就是为了将数据和与其相关的操作都封装到一起，对外只暴露接口，使得之中的数据操作被隐藏在接口之下，避免了用户对数据的误操作，这种行为就是封装。

如果把数据定义成了 public ，那么就没有封装性，因为用户可以随意存取并修改数据；如果把成员变量定义成了 protected ，那么 public 继承的派生类同样可以任意修改数据，也降低了数据成员的封装性。

另外还有一个理由就是升级，如果所有的数据成员都是私有的，那么调用者只能通过接口来得到想要的数据，以后如果这个数据被摒弃了，或者是用别的方式来得到了，都可以通过改变接口的实现来达到目的，而不用去修改用户代码，但是如果数据成员是 public 的，用户代码直接存取该成员，那么以后一旦这个成员变量被修改了，就会面临着所有直接使用了这个成员变量的用户代码都得修改。

同理，如果一个成员变量被声明为 protected 的，以后该变量被修改，那么所有这个变量所在类的派生类都会被修改，重新编译。

## 成员函数、友元函数还是非成员非友元

首先，友元的权限和成员函数的权限是相同的，所以从友元的角度来看一个自定义类，是没有封装性的，所有的东西都暴露给了友元。

如果把直接操作对象的操作称为数据的基本操作，而基于基本操作再得到别的效果的操作成为复杂操作的话，那么之前的说法应该修改：

> c++ 支持用户自定义类型，相较于 c 而言，就是为了将数据和与其相关的操作都封装到一起，对外只暴露接口，使得之中的数据操作被隐藏在接口之下，避免了用户对数据的误操作，这种行为就是封装。

上述说法应该被修改为：

> c++ 支持用户自定义类型，相较于 c 而言，就是为了将数据和与其相关的基本操作都封装到一起，对外只暴露接口，使得之中的数据操作被隐藏在基本操作的接口之下，避免了用户对数据的误操作，这种行为就是封装。

而那些基于基本操作实现的更繁琐的复杂操作应该作为非成员非友元函数，放置在与这个类相同的命名空间中。

此外还有一个情况下是应该考虑使用非成员版本的函数实现，那就是这个函数的参数列表可能都是需要经过类型转换的，比如一个自定义类型的乘法。

如果这个乘法实现为成员函数，那么乘法的第一个因子需要是自定义类型，如果是内置类型，那么就调用不了乘法。根据乘法的交换律，内置类型在乘号前后都应该是相同的结果，所以对于类似这种情况，比较好的办法就是定义一个友元函数（或者有接口可以获得数据也可以定义成是非友元的），两个参数类型都是自定义类型，然后在类中提供隐式类型转换函数，这样就可以了。

## 写一个不抛异常的 swap 函数

首先一点，标准库中已经存在了一个 std::swap() 模板函数，这个版本的函数是类似深拷贝的交换对象，但是对于那些通过指针来管理成员数据的设计，这种交换的代价未免大了些，所以我们可以根据需要手动重载一个只交换指针的版本。

这里的 swap 是一个模板函数，对比于模板类，我们说这种指定一个特定版本的行为为特化，方法是在类名后面加上尖括号，尖括号内为特换的参数，但是 C++ 的模板函数是没有特化的，不能类似的在函数名后面使用尖括号加上特化参数，C++ 的模板函数直接是使用重载。

如果现有的 swap 效率不高，那么应该操作以下步骤来实现一个不抛异常的高效特化版本 swap 函数：

1. 为你的类提供一个 public 的 swap 函数，让他高效的置换这个类的两个对象；
2. 在这个类对应的名称空间中提供一个非成员的 swap 函数，令他调用上述的成员 swap 函数；
3. 在要使用 swap 的函数中，使用`using std::swap;` 来声明 std::swap 函数，而不要直接`std::swap(obj1,obj2);`，因为这样的话指定调用的就是标准库版本的 swap 函数。

