# 习惯C++

## 以 const，enum，inline 替换 \#define

如果要声明一个常量，应该使用 const 修饰符，或者使用 enum 声明常量。其中使用 const 是在语言层次表示某个对象(对于内建类型而言就是变量)是不可修改的，而 enum 则是有些类似于 \#define ，相当于是对一个数值常量进行了有名替换。

这样做是为了在程序中添加对应的符号，而不是在预处理阶段将 \#define 的常量符号直接替换为数值常量。如果在程序中添加了表示常量的符号，这样在程序出错的时候可以直接定位到究竟是哪里出的问题，而如果使用 \#define ，编译器可能会只报告其对应的常量出错。（不过好像在现代编译器，已经不存在这个问题了。）

被 const 修饰的对象是不能够被修改的，也就是不能被当做左值被赋值，对于指针，const 与符号 '\*' 的位置之间有一些关系。

- 如果 const 位于 '\*' 之前(与类型名的位置没有关系)，则表示指针所指对象是不能被修改的，也就是 \*ptr 不能被当做左值。
- 如果 const 位于 '\*' 之后，则表示指针本身不能被修改，也就是 ptr 不能被当做左值，重新指向一个新的对象。

在使用 const 的时候，是不会将类型打开的，举个例子：

```c++
using IntPtr = int *;
int age = 18;
const IntPtr obj_a = &age;
IntPtr const obj_b = &age;
```

其中的 obj_a 和 obj_b 都是相同的类型，并没有把类型别名 IntPtr 打开，这里都是 obj_X 不能被当做左值。

\#define 还可以定义类似于函数的东西，典型的例子就是 C 当中定义一个能打印当前行的宏，而不显示调用：

```c++
#define print_debug(...) PRINT_DEBUG_UTIL(__LINE__,...)
```

当然，上述代码只是简单地演示，并不正确，但是意思到位了。对于打印行之类的，由于宏 `__LINE__` 表示的是该宏出现的行的行号，所以这类（print_debug）宏定义没法修改，但是对于一般的，比如 MAX(a,b) 之类的宏，是可以使用内联函数来替换 \#define 定义的。

使用 inline 来替换 #define 其实是为了避免涉及到自加自减类似表达式重复出现导致的逻辑错误，如果使用 inline 函数，效率是跟 #define 一样的，都是做行内扩展，但是 inline 毕竟是函数属性。

## 尽可能使用 const

首先一点，正确使用 const 可以避免不想被修改的对象出现在等号左边，如果出现，会直接在编译阶段报错。

C++ 有一个重要的特性，就是多态，其中一点就是函数重载，值得注意的一点就是，仅仅是常量性不同，也会发生重载。

```c++
template<typename T>
class Test{
    private:
        std::vector<T> m_data;
    public:
        T& operator[](const int index){return m_data[index];}
        const T& operator[](const int index) const {return m_data[index];}
    ...
};

int main()
{
    using namespace std;
    Test obj(...);
    const Test const_obj(...);
    cout << obj[8] << endl;     //调用的是 T& operator[](const int index)
    cout << const_obj[8] << endl;     //调用的是 const T& operator[](const int index) const
}
```

上述代码的 `operator[]` 有两个重载版本，如果是非 const 对象调用的 `operator[]` 则实际调用的是非 const 版本的实现，如果是一个 const 对象，则是调用的 const 版本实现。

## 确定对象在使用前已经被初始化

原因当然是避免程序出现未知行为，主要是有哪些注意事项。

对于一个自定义类型的对象来说，他的初始化一定是交给某个构造函数完成的，也就是构造就是自定义类型对象的初始化。而对于内建类型，编译器不负责调用构造函数，因为没有，所以就需要程序员手动显式的初始化。

```c++
class Test{...};
Test g_test;
int main()
{
    Test a;
    a = g_test;
}
```

上述代码涉及到两个问题：

1. 全局对象 g_test 应该在什么时候初始化？
2. `a = g_test` 是否是 a 的初始化操作？

先来解决第二个问题，可以明确的说，这个不是 a 的初始化，而是赋值操作。因为 a 在声明的时候调用了默认构造函数，这个时候才是 a 的初始化。

同样的道理，我们经常会在一个类的构造函数中带上形参，并且该形参是用来为类成员变量设定初值的，这个时候如果像处理 a 这样来对成员变量进程初始化就错了，函数体中的仅仅是赋值而已，实际上在赋值之前还经过了一个过程，就是成员变量首先调用了所属类型的默认构造函数，初始化了该成员，之后才在函数体内被再次赋值。

可以使用成员初始化列表来解决初始化的问题，并且经过上面的分析，使用成员初始化列表还能提高程序效率，节约了一次默认构造函数的调用。

不论是使用成员初始化列表还是怎么滴，成员的初始化顺序都是固定的，都是在类声明中的出现顺序，所以如果初始化过程有成员间依赖关系，需要调整类声明顺序。如果还涉及到继承，那么初始化的完整顺序是：

- 基类子对象(按继承顺序依次初始化)
- 成员对象(按声明顺序依次初始化)
- 构造函数中的用户代码

现在来回答之前的第二个问题，全局变量在什么时候初始化？答案是在进入 main 函数之前。编译器会产生额外的代码，在进入 main 的用户代码之前，会初始化所有全局变量（调用他们各自的构造函数），然后在 main 退出之前，调用他们各自的析构函数。

这就产生了一个新的问题，如果不同的源文件中有不同的全局变量，那么初始化顺序是怎样的？答案是不知道。编译器不能确定他们的初始化顺序，所以这个时候如果全局变量的初始化之间会有依赖关系，事情就会变得复杂起来。

不过好在有解决办法：

```c++
Test g_test_old;

Test& g_test_new(){
    static Test g_test_new;
    return g_test_new;
}
```

上述代码中的 g_test_old 是传统的使用全局变量的方法，用这种方法没有办法确定初始化实际，而 g_test_new() 是新的全局变量的使用方法，区别只在于多了一对括号。

使用新方法可以保证在第一次使用的时候才会被初始化，初始化的时机现在完全掌握在了程序员手中。