# 有关于实现

## 延后变量的定义时间

我们已经习惯了在程序段或者函数的最开始定义这个段落会用到的所有变量，甚至在嵌入式相关的编程中，有的编译器会告诉你，如果你没有把变量定义在程序段的最前边我就报错。

但是现在到了 c++ 中，因为我们有了自定义类型，一个变量的定义，就意味着构造过程的执行，当离开这个程序段的时候，还意味着自动变量析构函数的调用，这些都是需要成本的。

所以现在应该改变使用习惯，当马上要用到某个变量的时候才定义它，这是为了节约下面这种情况下的成本：

```c++
void func(bool right){
    base_class item1;
    base_class2 item2;
    derived_class item3;

    if(!right)
        return ;
    ...
}
```

如果函数的执行开关(right 变量)为假，那么三个对象的构造和析构函数会被分别调用，也就是会额外承担三个构造函数和三个析构函数的代价，然而这些代价在 right 为假的时候本不该承担。

## 关于类型转换

在 c 里面，类型转换是通过强制类型转换来实现，`(target_type)(value)`。不过在 c++ 中，提供了四种新式类型转换：

1. **const_cast\<T\>(expression)** 唯一能够移除常量性的转换，即 const 转 non-const；
2. **dynamic_cast\<T\>(expression)** 用于安全下行转换，因为采用的是 RTTI ，运行时类型检测，所以会造成重大的运行成本；
3. **reinterpret_cast\<T\>(expression)** 相当于强制类型转换，全都可以转，但是不保证安全性；
4. **static_cast\<T\>(expression)** 常用类型转换，一般的比如 int 转 double ，non-const 转 const 等；

当我们使用一个基类类型指针指向一个派生类对象的时候，所得到的地址值可能与派生类对象本身的地址值不同，这是因为此时取到的地址是派生类对象的子对象地址。**这个说法我还没有验证过，只是书上这样说。** 当我们想要获取一个派生类对象的一部分的时候，也就是其中的某一个基类子对象，应该使用类型转换，而不该是对指针做偏移然后调整类型，因为不同的编译器对于一个派生类对象的布局可能是不同的，我们不能假设他的布局情况。

当我们想要调用基类版本的函数的时候，可以直接使用作用域解析运算符来指定调用的版本，而不该调整指针来期望调用不同的版本。

如果可以的话，应该尽量避免在代码中做类型转换，特别是如果对运行速度有要求，那么应该尽量避免 dynamic_cast 的使用，因为下行安全类型转换会导致代码中复杂操作的执行，如果在设计中需要用到，那么应该考虑用别的替代设计方案，比如直接使用派生类对象，而不用 dynamic_cast\<base_class\>。

如果类型转换是必须的，尝试着将他包装于某个函数的内部，不用让用户来执行类型转换的操作。

## 避免返回 handles 指向对象的内部成分

这里所谓的 handles 指的是引用和指针，代表的是所指对象其本身。

函数的返回值，如果是引用，那么一定是非临时变量，要么是传入进来的引用参数本身，要么是 static 变量，要么就是成员变量。

对于成员变量来说，一般我们都应该将其设置为 private 的，如果这个时候返回的是一个非 const 的引用，那么会破坏他的封装性，可以直接通过这个函数来得到性质为 private 的内部成员变量引用，进而直接修改。

所以，如果返回的是一个临时变量，返回值应该是按值传递，否则若是指针或者引用，那么指向的就是一个被析构了的对象；如果返回的是一个成员变量，那么应该返回的是 const reference 属性的返回值。

## 异常安全性

所谓异常安全性，指的是当异常抛出的时候：

1. 不泄露任何资源；
2. 不允许数据被破坏。

对于第一点，是比较好实现的，我们有自定义的资源管理类，或者是智能指针，他们帮助管理资源，实现资源的自动释放，就能尽量避免资源的泄露了。

但是第二点就不那么好保证了。如果要完全保证异常抛出前后，数据是完全相同的，就需要跟踪保存异常抛出前的数据，以及异常抛出之后数据的恢复动作。所以会有退而求其次的设计实现，那就是保证异常抛出后，数据仍然是处于正确的状态，但是是否没有改变不能保证。

有一个保证异常安全的技术，CAS(copy and swap)，先拷贝一份要修改的数据的副本，然后在副本上完成所有的修改，之后将副本与实际要被修改的对象交换，那么如果在修改的过程中抛出了异常，原本的数据是没有被改动的，但是有一点，就是 swap 函数需要保证不抛异常。但是 CAS 会带来一些代价，副本的拷贝、析构，副本与被修改对象的交换。所以需要根据实际的应用场景来决定是否确实需要使用 CAS。

## 关于 inline

首先需要说明一点，inline 只是告诉编译器，申请这个函数是内联的，而不是强制的要求。声明了一个函数为 inline，但是并不代表它就是 inline，内联与否取决于编译器。

inline 是把函数调用替换为函数的本体，所以当我们在调用 inline 函数的时候，编译器要做替换，是需要知道函数究竟长什么样子，所以 inline 函数的定义一般是放在头文件里面，被使用到的源文件所包含，与此类似的就是模板。

一边来说，编译器会拒绝将复杂的函数内联，比如里面有循环或者递归，这种情况下，被声明为 inline 的函数就会被声明为 static 位于每一个被调用的源文件中。

对虚函数的调用也会阻止 inline 发生，因为 inline 函数是在编译阶段被调换为函数本体，但是虚函数的执行是需要动态确定的，而非是静态的，所以没有办法在编译阶段将函数本体替换。

另外，还有一种情况，使得 inline 既是内联又不是内联，那就是有*取内联函数地址* 的代码，这个时候在可执行程序文件里面是存在了该函数的，当我们通过函数指针来调用函数的时候，就不是 inline，实际就是一个调用函数的过程，但是如果有直接调用 inline 函数的代码，这个时候就是在编译阶段被函数本体替换了。

inline 函数有一个问题，那就是升级，当 inline 代码升级的时候，所有调用了这个 inline 函数的代码都需要重新编译。但是如果是非 inline 的函数，只需要重新连接就可以了。

## 降低文件间的编译依赖关系

