# 构造-析构-赋值

## C++会自动生成的函数

这个话题在学 C++ 的时候有提到过，可能会自动生成

- 默认构造函数
- 默认析构函数
- 默认拷贝构造函数
- 默认赋值运算符

具体情况比较复杂，参考两本书，《C++ primer》，《深入探索C++模型》。

简单来说有几点需要注意的地方，如果一个自定义类型有引用成员、const 成员，编译器是不会自动生成拷贝构造函数和赋值运算符函数的，因为编译器不知道该怎么处理对应的引用变量和 const 成员。

## 如果不需要编译器自动生成函数，主动屏蔽

如果一个对象，表示的东西就是独一无二的，那么拷贝构造函数、赋值运算符都是没有意义的，这个时候不能只是简单地不声明，因为这样的话，编译器是会帮你完成这些函数的声明+定义的，所以就需要显式的屏蔽掉编译器的生成行为。

具体方法就是将不需要编译器生成的函数，手动声明为 private 属性，这样的话外界就没有办法调用。不过这存在一个潜在的问题就是成员函数以及友元函数对这些函数的调用，解决办法就是只在 private 区域声明，但是不定义，这样即使成员函数和友元函数调用了这些期望被屏蔽的函数，也会因为没有定义而在链接阶段报错。

## 有关虚函数

如果一个类，期望作为基类，被别的类所继承，那么应该定义一个虚的析构函数，否则的话，如果是使用基类指针指向派生类对象，通过该基类指针来 delete 对象，但是同时析构函数又是非虚的，那么就会导致只析构了基类的成员，并没有析构掉派生类的成员，进而导致内存泄漏。

如果一个类是虚基类，那么最好不要在这个类里面声明非静态数据成员，如果这个虚基类有纯虚析构函数，应该同时为这个纯虚函数定义一个空的实现，因为派生类的析构会逐层调用基类的析构函数。

什么时候该声明析构函数是虚的？

如果这个类要被继承，那么就声明为虚的，否则最好不要。这个是从代价方面来考虑的，因为一旦类声明中出现了虚函数，那么为了支持虚这个特性，就会产生虚表，虚表的产生会带来很多代价，如必须生成构造函数、拷贝构造函数、赋值运算符，当然，如果使用了才必须生成；还比如多一个指针的内存占用等。