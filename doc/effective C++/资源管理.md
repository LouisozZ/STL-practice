# 资源管理

<!-- TOC -->
- [资源管理](#资源管理)
  - [以对象管理资源](#以对象管理资源)
  - [在资源管理类中提供对原始资源的访问接口](#在资源管理类中提供对原始资源的访问接口)
  - [单独把 newed 的对象放到智能指针](#单独把-newed-的对象放到智能指针)

什么是资源？我们最常接触到的，也一定会接触到的就是内存，在堆上分配的内存，如果不使用了，应该还给系统，否则的话就是资源泄露。还有别的资源，比如，linux 环境下的锁，文件描述符，socket 等。

当我们向系统申请了资源之后，使用完了之后是需要释放的，如果我们手动的去申请、释放，总免不了有可能会漏掉，对于明显的资源申请，可以做到追踪释放，虽然并不是一件简单的事情，但是还有一些，是在函数中进行资源申请，返回指向这个资源的指针或者引用，如果单独还好，但是如果匿名中间变量也是通过这个函数来得到，那么这个资源的释放就变得不是那么显而易见了。

```c++
T& func(T& a, T& b){
    return new T(a*b);
}

double a = func(func(b,c),d);
//由 func(b,c) 产生的匿名变量就不那么容易被发现了
```

所以如果有技术能够保证资源在离开他的作用域的时候能够自动被释放，那么就不用担心资源泄露了。

结合上述的需求，所以就出现了智能指针。其实智能指针就是一个类，利用了类的析构函数特性，当一个对象离开其作用域、生命周期结束、被 delete 的时候都会自动调用它的析构函数，如果在析构函数里面对资源进行释放，就能起到自动管理资源的作用。

## 以对象管理资源

智能指针有三种：

- unique_ptr
- auto_ptr
- shared_ptr

他们都是模板类，他们的区别请参考 [智能内存管理](../c++基础/智能内存管理.md)。

虽然有智能指针，不过如果设计的类有特殊需求，比如不允许复制资源等等，也可以自己设计一个资源管理类，根据特定的需求来定制一个资源管理类。

## 在资源管理类中提供对原始资源的访问接口

拿锁来举例，linux 的系统调用接口参数都是原始资源的相关类型，这个时候直接传递资源管理对象当然是错误的，所以这种情况下应该提供对原始资源的访问接口。

```c++
std::shared_ptr<Mutex> log_mutex(new Mutex);
mutex_lock(log_mutex.get());
```

幸运的是，标准库的智能指针类都提供了 `get()` 方法，用来获得原始资源。对于自己设计的资源管理类，也应该提供类似的接口。

## 单独把 newed 的对象放到智能指针

由于 new 可能会抛出异常，所以应该单独被执行。

如果想直接返回一个临时匿名变量作为某个函数的参数，可能会存在异常安全性的问题，此时如果这个函数还接受了另一个参数，这个参数也是通过函数得到的匿名临时变量，但是这个函数是会修改当前程序的数据，或者申请、释放资源，那么当 new 抛出异常的时候，可能会破坏掉当前程序的状态，因为这两个函数的执行顺序是未知的。

```c++
void func_change(){
    g_data = x;
    return;
}

int main(){
    func_invoke(std::shared_ptr<T>(new T),func_change());
    //std::shared_ptr<T>(new T) 和 func_change 的调用顺序未知，所以导致了异常安全性问题

    std::shared_ptr<T> para1(new T);
    func_invoke(para1,func_change());
    //消除了上述的异常安全性问题。
    ...
}
```