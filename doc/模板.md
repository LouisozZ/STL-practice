# C++ 模板
## 为什么使用模板？
对于逻辑以及设计相同的模块，如果仅仅是有类型的差别，而需要针对类型相关部分做相应的调整，那么可以将这个模块定义为模板类型，以提高代码重用性和稳定性（稳定性体现在，使用模板避免了在频繁修改中，出现遗漏，进而产生bug的现象）。
## 模板前缀
### template \<typename Type\>
一个模板（不论是函数模板还是类模板）应该以上述的代码开头，即模板前缀。如果是一个类模板，那么应该在类定义之前显示书写这一句；如果是模板函数定义，那么应该在函数定义之前显示书写这一句；如果是模板类中的成员函数，那么应该在其成员函数定义的前面显示书写这一句，并且在作用域运算符前的类说明后面，用尖括号说明该模板类的当前类型（因为在定义时候不知道实际调用时类型，所以与模板函数的模板类定义时一样，用 Type 来说明类型）。稍后还将说明，上述说法只是为了用理解类与函数的方式来理解模板，实际上，模板的定义并不能被称为对应的类和成员函数的定义。

## 函数模板

### 定义函数模板

### 使用函数模板


## 类模板 
### 定义类模板
类模板的定义不仅包含了类的定义说明，还包含了类成员函数的定义说明。

示例 :
```c++
//类模板定义说明
template <typename Type>
class Stack{
    private:
        enum {MAX = 10};    //据《effective c++》，用枚举或者const常量来替换使用 #define 的方式
        Type Item[MAX];     //告知编译器，用通用类型说明符来声明栈元素，当实际使用模板的时候，编译器会使用实际的类型来替换 Type
        int top;
    public:
        Stack();
        bool isempty();
        bool isfull();
        bool push(const Type& item);    //push item into stack
        bool pop(Type& item);           //pop the top into item
};
//类模板的成员函数定义说明
template <typename Type>
Stack<Type>::Stack()
{
    top = 0;
}

template <typename Type>
bool Stack<Type>::isempty()
{
    return top == 0;
}

template <typename Type>
bool Stack<Type>::isfull()
{
    return top == MAX;
}

template <typename Type>
bool Stack<Type>::push(const Type& item)
{
    if(top < MAX)
    {
        Item[top++] = item;
        return true;
    }
    return false;
}

template <typename Type>
bool Stack<Type>::pop(Type& item)
{
    if(top <= 0)
        return false;  
    item = Item[--top];
    return true;
}
```
#### 说明
一个 **template \<typename Type\>** 是有其作用域的，当后面跟着的是一个函数的时候，说明的是这个函数的定义方式；而如果后面跟的是一个类定义，那么这个模板说明的是是整个类的定义，所以要是类中有一个内联函数使用了类型通用说明符，那么是可以省略模板前缀的。

对于上述的代码，一个模板前缀出现在类定义前面的时候，类成员函数声明的时候是直接使用的 Type
```c++
template <typename Type>
class Stack{
    ...
    public:
        bool push(const Type& item);    //push item into stack
    ...
};
```
而一个类模板的每个成员函数在定义的时候都需要加上模板前缀，并且类限定符还必须加上通用类型说明符。
```c++
...
template <typename Type>
bool Stack<Type>::isempty()
{
    return top == 0;
}

template <typename Type>
bool Stack<Type>::isfull()
{
    return top == MAX;
}
...
```
呼应前文 ：
>稍后还将说明，上述说法只是为了用理解类与函数的方式来理解模板，实际上，模板的定义并不能被称为对应的类和成员函数的定义。

模板前缀以及其后所跟模板内容，是写给编译器看的，是**编译器指令**，说明了如何生成类和（成员）函数的定义。一个模板的声明并不能单独的放到一个文件中编译，因为模板单独编译并没有意义，模板必须与特定的模板实例化请求一同使用，由此，模板信息（模板的定义）应该单独放到一个头文件中，并在要使用这些模板的文件中包含该头文件。
### 使用类模板
仅在源文件中包含类模板说明是不能够生成模板类的，模板必须与特定的实例化请求一同出现才会生成一个独立的类，所以声明一个类型为模板的类，方法就是用所需的具体类型来替换泛型名：
```c++
Stack<int> Int_Stack;       //声明一个栈元素是 int 类型的栈
Stack<std::string> String_Stack; //声明一个栈元素是 string 类型的栈
```
编译器在检索到上述的代码时候，会生成**两套独立的类声明**，分别用 int 和 std::string 来替换类模板中的 Type 。值得被注意的一点是，std::string 是一个类！所以由此看来，模板是能够接收内置类型和自定义的类类型。
#### 深入讨论-关于指针类型
拿 Stack\<std::string\> 来举例对比指针类型。现有代码如下：
```c++
int main()
{
    Stack<std::string> string_stack;
    std::string input;
    std::cin >> input;
    string_stack.push(input);
    string_stack.pop(input);
    return 0;
}
```
上述代码可以正常工作，但是如果做如下改变:
>Stack\<std::string\>  -->  Stack\<char \*\>

那么会出现哪些问题？

为了适应 char \* 的栈元素类型，对于 input ，其类型也要发生变化，第一种情况 : **char \* input**
```c++
int main()
{
    Stack<char *> string_stack;
    char* input;
    std::cin >> input;
    string_stack.push(input);
    string_stack.pop(input);
    return 0;
}
```
**问题**：从键盘获取数据的时候没有分配内存来保存。

第二种情况 : **char input[INPUT_MAX]**
```c++
    char input[INPUT_MAX]
```
**问题**：Stack\<char \*\>::pop() 实现中，传入的是一个能赋值的左值
```c++
bool Stack<Type>::pop(Type& item)
{
    if(top <= 0)
        return false;  
    item = Item[--top];     //数组名不能作为左值被赋值
    return true;
}
```
而这里的是一个数组名，不能被赋值。

第三种情况：**char\* input = new char[40]**
```c++
    char* input = new char[40]
```
**问题**：Stack\<char \*\>::push() 实现中，如果是一个值，那么直接会保存在栈元素中，如果是一个类，那么重定义了赋值运算符，会调用赋值构造函数，重新初始化栈元素为传入参数，但是如果是一个指针，那么保存的是指针值，即所有的栈元素指向的都是同一块地址。
```c++
bool Stack<Type>::push(const Type& item)
{
    if(top < MAX)
    {
        Item[top++] = item;     //此时每一个Item元素保存的都是同一个内存地址
        return true;
    }
    return false;
}
```
##### 关于涉及到指针模板的小结
综上所述，其实当涉及到指针操作的时候，类似于考虑构造函数的情形，需要考虑指针及其内容的物理意义，指针的值是一个内存地址，所指向的内存区域的数据才是用户期望得到的值。那么涉及到指针的处理的时候，其实跟 string 类的设计原理是一样的：
1. 设计各种构造函数以及重载赋值运算符，用入参初始化新分配的内存，以此来保证保存在栈中的数据有效。
2. 设计对应的析构函数来管理内存。
3. ...

