# 类构造函数
## 引言
为什么需要类构造函数？

对于一个有私有成员变量的类来说，怎么样给这些私有变量赋值是一个问题。首先一点，私有成员不能在外部被访问，所以想要通过类似初始化列表的方式来初始化类私有成员函数是不行的，这会违背私有特性，使用初始化列表就意味着是在外部直接访问一个对象的私有变量。那么还有一种方式就是通过成员函数，假如已经设计了初始化成员函数来对私有成员对象赋值，那么在调用任意需要操作私有成员变量的函数之前，都必须假设已经调用了初始化成员函数，否则对未初始化的变量进行操作，结果总是未知的。所以构造函数，就是一个在对象被创建的时候自动被调用的函数，可以用它来对对象进行初始化。

## 构造函数说明
**任何时候，只要对象被创建了，就一定会调用构造函数！！！**

不论构造函数的形式是怎样的，构造函数的函数名都是与类名相同，并且没有返回值，而且访问控制应该为 public ，这是因为构造函数是一个公用接口才能在外部被调用。所以一个构造函数最基本的样子应该是:
```c++
class MytestClass{
    public:
        MytestClass(/*parameter list*/);
        ...
};
MytestClass::MytestClass(/*parameter list*/)
{
    /* init code */
}
```
在设计成员函数的时候，需要注意的一点就是形参名字不能与类成员变量名字相同，这是因为在类的作用域中，成员变量是可以直接被使用的，示例如下：
```c++
class MytestClass{
    private:
        std::string name;
        int age;
    public:
        MytestClass(std::string input_name, int actual_age);
        //int changedata(std::string input_name, int actual_age);
        int changedata();
};
MytestClass::changedata()
{
    age = 24;
    name = "louis";
    return 0;
}
```
对于上述的成员函数，此时的 name 和 age 的意义是明确的，是类的成员变量，当一个对象被创建的时候，实际操作的就是调用这个成员函数的对象的成员变量。

可是如果现在调整了函数接口，有了入参，且形参的名字与类成员变量的名字相同，这个时候就不知道 name 和 age 分别指代的是什么了。
```c++
MytestClass::changedata(std::string name, int age)
{
    age = age;
    name = name;
    return 0;
}
```
即使上述的代码能正常运行，即运行不报错，实际产生的效果顶多就是不会对成员变量的值造成修改，可是如果构造函数也是如此，形参名字与成员变量名字相同，那么就会导致未初始化成员变量，或者甚至是更严重的错误。

所以综上所述，所有类成员函数的设计，其形参都不能与成员变量名相同（同理也不能与成员函数名相同），为此，也可以是在每个成员变量名字前加上前缀 **m_** 以此来说明该变量为成员（member）变量。
```c++
class MytestClass{
    private:
        std::string m_name;
        int m_age;
    ...
};
```
## 构造函数调用方式
构造函数可以显式地被调用，也可以隐式地被调用。
```c++
class MytestClass{
    private:
        std::string m_name;
        int m_age;
    ...
    public:
        MytestClass(const std::string & name, int age = 0){ m_name = name; m_age = age;};
    ...
};
int main()
{
    //显式调用构造函数
    MytestClass object1 = MytestClass("louis",24);
    //隐式调用构造函数
    MytestClass object2("louisister",14);
    //与 new 一同使用
    MytestClass *object3_ptr = new MytestClass("louisgf",18);
    ...
    return 0;
}
```
显式调用的时候直接调用构造函数名即可，因为类名会在整个程序的作用域中唯一，所以对应的构造函数也只有该类所持有的唯一一个，故而编译器是能够正确定位函数的。隐式调用是直接在声明的对象后面用括号加上参数列表就可以了。

但是不能通过对象调用构造函数来初始化，因为构造函数是用来创建对象的，在调用构造函数之前并没有对象存在，所以此时是没法通过对象来调用构造函数的。如果对一个已经存在的对象显示调用构造函数编译器会报错。

但是可以通过构造函数重置一个对象，格式如下，并非通过对象调用，而是使用一个临时对象来赋值：
```c++
object1 = MytestClass("chubby",23);
```
当这个新的临时对象完成赋值动作之后就会调用析构函数来释放这个对象。（删除时机不一定是立即，根据编译器的不同会有不同的删除时机）

c++ 的对象也支持列表初始化，但是列表中的内容应该跟某个构造函数的参数列表是匹配的，因为无论如何，类都是通过构造函数来新建一个对象的。如果列表初始化的指定列表为空，则调用的是默认构造函数：
```c++
MytestClass object1 {"chubby",23};
MytestClass object2 = {"chubby",23};
MytestClass object3 {};
```
> 有关于 **new** 的部分可以参考 [有关于new和delete.md](./有关于new和delete.md) 。


## 构造函数分类
### 默认构造函数
默认构造函数是在声明时没有提供显示初始值的时候，用来创建对象的构造函数。一个类有且只能有一个默认构造函数，否则的话会产生二义性，一个对象在声明的时候没有指定初始值，但是因为存在了多个默认构造函数，所以不知道该调用哪个。

如果在写类声明的时候没有定义任何构造函数，那么 c++ 会自动添加一个默认构造函数，但是这个默认构造函数并不做任何事情，这个 c++ 添加的默认构造函数被调用的结果是创建了一个新的对象，但是其中的数据成员都没有被初始化。然而，一旦写了一个构造函数，那么程序员就必须添加一个默认构造函数。

### 复制构造函数
在 c++ 中，把一个对象赋值给另一个对象，默认的行为是把源对象的每个数据成员复制到目标对象的数据成员中。
12.5 

## 小知识点
1. 定义位于类声明中的函数都将自动成为内联函数。也可以在类定义外部定义一个内联函数，只需要在普通成员函数的定义前面加上关键字 inline 就显式地定义了一个内联函数。
   > 根据内联函数的特殊规则，要求在每个使用到内联函数的文件中都要定义它们，所以一个简单的方法就是将要使用的内联函数写到相关的头文件中，这样的话在包含头文件的时候就可以自动将内联函数定义在了文件开头，后面就可以直接使用了。
2. 在类里面声明一个常量来规定数组大小的时候（或者类似的情景），使用下述的方式是错的：
   ```c++
   class Test{
        private:
        const int MAX_LENGTH = 10;
        int my_arr[MAX_LENGTH];     //error!!!
        ...
   };
   ```
   因为一个类，是描述一个对象的蓝本，要创建这个类的一个对象，由类定义来描述这个对象应该具备什么东西。类成员函数应该是存放在代码段，而且是在编译阶段已经确定放在了 .txt 段（由实验得出的结论，在主函数里未创建对象的时候生成的可执行文件大小是 x ，只创建一个对象，重新编译生成的可执行文件大小是 x+y，生成两个对象的时候，重新编译生成的可执行文件大小是 x+2y）。所以如果在一个类里面声明的是一个 const 类型的变量，仅仅会在程序加载到内存并执行对象声明的时候才会为这个变量分配内存并初始化值，所以在第二句限定一个数组大小的时候，是没有办法知道这个 MAX_LENGTH 的数值的，因此会报错，但是如果是一个枚举或者是 static 变量则不然，因为这两种类型的变量是会被放置到一个程序的数据段中保存的，是在编译阶段就会分配大小并赋值，而且这一句一定是在数组声明的前面，所以编译器是能够知道 MAX_LENGTH 的大小的。
3. 有关于类中的枚举。在同一个作用域中，如果有多个枚举定义，那么每个定义之间是不能有相同的枚举名的，因为如果有，那么在赋值的时候编译器是没办法知道究竟是使用哪个枚举定义中的枚举量。所以鉴于此， c++11 提供了一种特性，枚举的作用域是一个类，是一个在定义枚举的时候显示说明的：
   ```c++
   enum class HouseSize{Small,Medium,Large};
   enum class AppleSize{Small,Medium,Large};
   class Test{
       ...
       enum class TshirtSize{Small,Medium,Large};
       TshirtSize myshirt;
       Test(){myshirt = TshirtSize::Medium;}
       ...
   };
   int main()
   {
       AppleSize your_apple = AppleSize::Small;
       ...
   }
   ```
   这样的话，就不会出现重名的问题，每个枚举类都有自己的作用域，不过就是使用的时候需要制定限定类。
   
