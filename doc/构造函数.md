# 类构造函数
## 引言
为什么需要类构造函数？

对于一个有私有成员变量的类来说，怎么样给这些私有变量赋值是一个问题。首先一点，私有成员不能在外部被访问，所以想要通过类似初始化列表的方式来初始化类私有成员函数是不行的，这会违背私有特性，使用初始化列表就意味着是在外部直接访问一个对象的私有变量。那么还有一种方式就是通过成员函数，假如已经设计了初始化成员函数来对私有成员对象赋值，那么在调用任意需要操作私有成员变量的函数之前，都必须假设已经调用了初始化成员函数，否则对未初始化的变量进行操作，结果总是未知的。所以构造函数，就是一个在对象被创建的时候自动被调用的函数，可以用它来对对象进行初始化。

## 构造函数说明
**任何时候，只要对象被创建了，就一定会调用构造函数！！！**

不论构造函数的形式是怎样的，构造函数的函数名都是与类名相同，并且没有返回值，而且访问控制应该为 public ，这是因为构造函数是一个公用接口才能在外部被调用。所以一个构造函数最基本的样子应该是:
```c++
class MytestClass{
    public:
        MytestClass(/*parameter list*/);
        ...
};
MytestClass::MytestClass(/*parameter list*/)
{
    /* init code */
}
```
在设计成员函数的时候，需要注意的一点就是形参名字不能与类成员变量名字相同，这是因为在类的作用域中，成员变量是可以直接被使用的，示例如下：
```c++
class MytestClass{
    private:
        std::string name;
        int age;
    public:
        MytestClass(std::string input_name, int actual_age);
        //int changedata(std::string input_name, int actual_age);
        int changedata();
};
MytestClass::changedata()
{
    age = 24;
    name = "louis";
    return 0;
}
```
对于上述的成员函数，此时的 name 和 age 的意义是明确的，是类的成员变量，当一个对象被创建的时候，实际操作的就是调用这个成员函数的对象的成员变量。

可是如果现在调整了函数接口，有了入参，且形参的名字与类成员变量的名字相同，这个时候就不知道 name 和 age 分别指代的是什么了。
```c++
MytestClass::changedata(std::string name, int age)
{
    age = age;
    name = name;
    return 0;
}
```
即使上述的代码能正常运行，即运行不报错，实际产生的效果顶多就是不会对成员变量的值造成修改，可是如果构造函数也是如此，形参名字与成员变量名字相同，那么就会导致未初始化成员变量，或者甚至是更严重的错误。

所以综上所述，所有类成员函数的设计，其形参都不能与成员变量名相同（同理也不能与成员函数名相同），为此，也可以是在每个成员变量名字前加上前缀 **m_** 以此来说明该变量为成员（member）变量。
```c++
class MytestClass{
    private:
        std::string m_name;
        int m_age;
    ...
};
```
## 构造函数调用方式
构造函数可以显式地被调用，也可以隐式地被调用。
```c++
class MytestClass{
    private:
        std::string m_name;
        int m_age;
    ...
    public:
        MytestClass(const std::string & name, int age = 0){ m_name = name; m_age = age;};
    ...
};
int main()
{
    //显式调用构造函数
    MytestClass object1 = MytestClass("louis",24);
    //隐式调用构造函数
    MytestClass object2("louisister",14);
    //与 new 一同使用
    MytestClass *object3_ptr = new MytestClass("louisgf",18);
    ...
    return 0;
}
```
显式调用的时候直接调用构造函数名即可，因为类名会在整个程序的作用域中唯一，所以对应的构造函数也只有该类所持有的唯一一个，故而编译器是能够正确定位函数的。隐式调用是直接在声明的对象后面用括号加上参数列表就可以了。

但是不能通过对象调用构造函数来初始化，因为构造函数是用来创建对象的，在调用构造函数之前并没有对象存在，所以此时是没法通过对象来调用构造函数的。如果对一个已经存在的对象显式调用构造函数编译器会报错。

但是可以通过构造函数重置一个对象，格式如下，并非通过对象调用，而是使用一个临时对象来赋值：
```c++
object1 = MytestClass("chubby",23);
```
当这个新的临时对象完成赋值动作之后就会调用析构函数来释放这个对象。（删除时机不一定是立即，根据编译器的不同会有不同的删除时机）

c++ 的对象也支持列表初始化，但是列表中的内容应该跟某个构造函数的参数列表是匹配的，因为无论如何，类都是通过构造函数来新建一个对象的。如果列表初始化的指定列表为空，则调用的是默认构造函数：
```c++
MytestClass object1 {"chubby",23};
MytestClass object2 = {"chubby",23};
MytestClass object3 {};
```
> 有关于 **new** 的部分可以参考 [有关于new和delete.md](./有关于new和delete.md) 。

当一个类有多个构造函数并且其中有使用 new 来分配内存，这个时候就需要注意，各个构造函数中的 new 应该是用同样的调用方式，要么都带中括号，要么都不带，因为只有一个析构函数，所以需要保证使用的 delete 与所有的 new 都是匹配的。

## 跟构造函数相关的转换函数
对于标准类型来说，我们把从 int 到 double 的转换称为类型转换，而对于自定义的类型（一个类），他与标准类型之间的转换也被称为是类型转换，但是两个自定义类型之间，如果不是继承关系，那么他们的相互转换是没有意义的。

如果一个构造函数的最少接收参数只有一个（包括仅有一个参数的形式和只剩一个没有默认值的形式），并且等号右边的值可以转换为该类型，那么程序在执行的时候会产生隐式类型转换效果，此时这个构造函数也称为转换函数。
```c++
class Test
{
    public:
        Test(int i);
        Test(double d,int i = 0, short s = 8);
        ...
};
int main()
{
    Test item1;
    Test item2;
    item1 = 5;
    item2 = 9.0;

}
```
上述代码中其实是有问题的，因为此时的两个构造函数，都可以作为转换函数，并且 double 的作用范围是覆盖了 int 的，所以当被转换的参数是一个整数的时候，是会出现二义性的。

> 假设不会出现二义性，现在来讨论转换函数的转换过程。对于 item1 ，首先会产生一个临时变量，该临时变量以 5 作为入参，调用构造函数 Test(int)，然后该临时对象组成员赋值给 item1（赋值方式是通过重载的[赋值运算符](#复制构造函数)来实现的），赋值结束后释放临时变量。对于 item2 ，同样先产生一个临时变量，调用构造函数 Test(double,int,short) 来初始化，然后组成员赋值给 item2 ，完成之后释放临时变量。

再来看一种情况：
```c++
class Test
{
    public:
        Test(double d,int i = 0, short s = 8);
        ...
};
void display(Test& item,int k);
int main()
{
    display(9,5);
}
```
对于函数 display ，接收的第一个参数应该是 Test& ，但是传入的是一个整型，此时编译器会先查找 Test 类的构造函数，检查到与 Test(double,int,short) 匹配，这个时候会先将 9 转换为 double 类型，然后调用构造函数，转换为一个 Test 类型。

由于这种隐式转换的特性有时候会带来隐藏的 bug ，所以 C++ 提供了一个关键字 **explicit** 来关闭这种特性，使得这种转换只能显式地由程序员调用。
```c++
class Test{
    explicit Test(double i);
};
int main()
{
    Test item1;
    item1 = 19.5;       //error!
    item1 = Test(19.5); //right
}
```

那么，既然有正向，那么反向的转换函数又是怎样呢？
> 设 -- \[正向\] ==== 自定义类型 ---> 标准类型 \
设 -- \[反向\] ==== 标准类型 ---> 自定义类型

对于正向而言，是从一个没有对象到有一个对象的过程，所以正向的类型转换函数就是这个自定义类型的构造函数，但是反向的却不行，因为是从一个对象到一个标准类型，所以需要显式定义转换函数。如果有一条语句是反向转换的，但是检索类方法却没有转换函数，这个时候就会报错。**所以从上述内容可知，如果使用了 explicit 关键字来声明一个类构造函数，那么当遇到一个标准类型的赋值的时候，就不会隐式地调用这个构造函数来做类型转换，而是需要显式的调用构造函数，生成一个临时变量，然后使用这个临时变量通过重载的赋值运算符来初始化或重置一个对象。（如果定义了重载的赋值运算符则使用程序员显式定义的，否则编译器会自动生成一个重载的赋值运算符函数）**

转换函数的定义：
```c++
operator Typename();
```
其中 Typename 为转换函数的目标转换类型（标准类型）。

转换函数的注意点：
1. **转换函数必须是类方法；**
2. **转换函数不能指定返回值类型；**
3. **转换函数没有参数。**
```c++
class Test{
    public:
        operator double() const;
};
Test::operator double() const{
    ...
}
int main()
{
    Test item(5.0);
    double d = double (item);
    double k = (double) item;
}
```
main 中的两种转换方式都是正确的。

**转换函数总结：** 只有一个参数的构造函数将被用作正向转换函数。反向转换函数必须是类成员，没有返回值、没有参数、用于将一个对象转换为标准类型。 

## 构造函数分类
### 默认构造函数
默认构造函数是在声明时没有提供显式初始值的时候，用来创建对象的构造函数。一个类有且只能有一个默认构造函数，否则的话会产生二义性，一个对象在声明的时候没有指定初始值，但是因为存在了多个默认构造函数，所以不知道该调用哪个。

如果在写类声明的时候没有定义任何构造函数，那么 c++ 会自动添加一个默认构造函数，但是这个默认构造函数并不做任何事情，这个 c++ 添加的默认构造函数被调用的结果是创建了一个新的对象，但是其中的数据成员都没有被初始化。然而，一旦写了一个构造函数，那么程序员就必须添加一个默认构造函数。

### 复制构造函数
复制构造函数，就是创造一个已有对象的副本。复制构造函数的函数原型：
```c++
ClassName::ClassName(const ClassName &);
```
如果程序员没有提供复制构造函数，并且在编码中使用了一个已有对象赋值给一个新建对象：
```c++
ClassName item1('a',4,"louis");
//以下的五种方式都将调用复制构造函数
ClassName newitem1 = item1;                 // 1
ClassName newitem2(item1);                  // 2
ClassName newitem3 = ClassName(item1);      // 3
ClassName* newitem4 = new ClassName(item1); // 4

ClassName function(ClassName item);
function(item1);            // 5 按值传递参数的时候，也会通过复制构造函数产生一个临时对象
ClassName newitem6 = function(item1);       // 6 function 的返回值类型是一个 ClassName ，是按值传递的。所以返回的时候会产生一个临时对象，故而会调用复制构造函数
```
此时编译器会自动生成一个默认的复制构造函数，其行为是逐成员复制，但是只是将值进行一次拷贝（浅拷贝），对于类似指针这种数据类型，仅仅拷贝的是指针的值，并没有新分配内存来拷贝所指向的内存，所以一个已有对象和经过这种复制构造函数产生的副本指向的是同一块内存。如果一个类的成员是另一个类的对象，那么会调用那个类的复制构造函数来完成对这个类成员的拷贝工作。

上述的五种方式中，其中第一种和第三种的具体过程因实现不同而不同，可能会先生成一个临时变量，然后用这个临时变量来对新变量进行赋值，也可能直接对新对象赋值。第四种方式的过程，是生成一个匿名变量，然后将该匿名变量的地址赋值给新的对象指针。**不过不管怎么说，只要会产生临时对象，就都会调用类的复制构造函数，来产生一个原始对象的副本。所以按值传递和按值返回的时候，都是会调用复制构造函数的。因此在函数调用中，在符合逻辑的情况下应该尽量使用引用，以此来减少内存和时间开销，使得程序的运行速度更快。**

而对于不是在创建对象的时候赋值，编译器会自动生成一个 **赋值运算符重载函数** ，其行为与默认复制构造函数相同。
```c++
ClassName item1('a',4,"louis");
ClassName newitem;
newitem = item1;    // 调用自动生成的赋值运算符重载函数来对 newitem 赋值
```
> 关于编译器会自动生成哪些函数，请参考[编译器会自动生成的函数](#编译器会自动生成的函数)

在重载赋值运算符的时候需要注意一点，应该先判断**是否是自己在给自己赋值**。因为对于一个对象的深拷贝，如果有指针，那么在给他分配新的内存之前，会先释放掉原来指向的内存，来防止内存泄露，所以如果给他赋值的是其本身，那么会释放掉即将给他赋值的那块内存，从而破坏了数据的正确性，并且一个对象对其本身进行赋值也是没有必要再做一次拷贝的，所以直接返回就好了。
```c++
class Test{
    public:
        Test & operator =(const Test&);
};
Test& Test::operator =(const Test& item)
{
    if(&item == this)   
        return *this;
    
    delete pointer;
    pointer = new type;
    memcpy(pointer,item.pointer,size);
    ...
}
```
在上述的代码中，使用地址而不用值来做判断，一是因为 == 运算符需要重载才能对两个自定义类型的对象进行比较，二是如果重载了，按照逻辑来说，只要值（如果有指针则是指针的内容而不是指针值）相同的两个对象就会判断为是相同的，与这里我们想要检查的是否是同一个对象有偏差。


## 小知识点
1. 定义位于类声明中的函数都将自动成为内联函数。也可以在类定义外部定义一个内联函数，只需要在普通成员函数的定义前面加上关键字 inline 就显式地定义了一个内联函数。
   > 根据内联函数的特殊规则，要求在每个使用到内联函数的文件中都要定义它们(**本质上的原因是因为 inline 关键字使得函数的链接性成为内部链接性，只有在文件内部才能知道这个是 inline 的，并且被声明为 inline 的函数在外部是不能被访问的**)，所以一个简单的方法就是将要使用的内联函数写到相关的头文件中，这样的话在包含头文件的时候就可以自动将内联函数定义在了文件开头，后面就可以直接使用了。
2. 在类里面声明一个常量来规定数组大小的时候（或者类似的情景），使用下述的方式是错的：
   ```c++
   class Test{
        private:
        // const int MAX_LENGTH = 10;    //error!!!
        static int MAX_LENGTH;
        int my_arr[MAX_LENGTH];    
        ...
   };
   int Test::MAX_LENGTH = 10;   //right
   ```
   因为一个类，是描述一个对象的**蓝本,仅仅是用来描述说明该如何创建一个对象**，要创建这个类的一个对象，由类定义来描述这个对象应该具备什么东西。类成员函数应该是存放在代码段，而且是在编译阶段已经确定放在了 .txt 段（由实验得出的结论，在主函数里未创建对象的时候生成的可执行文件大小是 x ，只创建一个对象，重新编译生成的可执行文件大小是 x+y，生成两个对象的时候，重新编译生成的可执行文件大小是 x+2y）。所以如果在一个类里面声明的是一个 const 类型的变量，仅仅会在程序加载到内存并执行对象声明的时候才会为这个变量分配内存并初始化值，所以**在创建这个对象的时候，** 为其指定的数组长度值 MAX_LENGTH 是没有办法知道，因此会报错。但是如果是一个枚举或者是 static 变量则不然，因为这两种类型的变量是会被放置到一个程序的数据段中保存的，是在编译阶段就会分配大小并被初始化，所以编译器是能够知道 MAX_LENGTH 的大小的。
   > 需要说明一点，类的静态成员变量是在类定义之外被初始化的，直接通过作用域解析运算符与 static 变量名来定位一个变量并初始化。**不能在类定义中初始化静态成员！！** 因为类定义只是对如何创建对象的一个描述，所以在类定义阶段是没有分配内存的，故而任何初始化都是无效的。并且这条单独的初始化语句应该放在方法文件中，如果放在了头文件里面，当别的文件要使用相关类的时候，会包含头文件，可能会出现重复初始化的问题，从而导致错误。\
   但是也有例外，如果是一个 const 的整型变量或者是枚举变量，还是可以在类定义中初始化的。
3. 有关于类中的枚举。在同一个作用域中，如果有多个枚举定义，那么每个定义之间是不能有相同的枚举名的，因为如果有，那么在赋值的时候编译器是没办法知道究竟是使用哪个枚举定义中的枚举量。所以鉴于此， c++11 提供了一种特性，枚举的作用域是一个类，是一个在定义枚举的时候显式说明的：
   ```c++
   enum class HouseSize{Small,Medium,Large};
   enum class AppleSize{Small,Medium,Large};
   class Test{
       ...
       enum class TshirtSize{Small,Medium,Large};
       TshirtSize myshirt;
       Test(){myshirt = TshirtSize::Medium;}
       ...
   };
   int main()
   {
       AppleSize your_apple = AppleSize::Small;
       ...
   }
   ```
   这样的话，就不会出现重名的问题，每个枚举类都有自己的作用域，不过就是使用的时候需要制定限定类。
4. 有一些函数必须是类方法：
    - **类型转换函数** \
    从标准类型到自定义类型的转换函数是构造函数，是也只能是类成员函数；从自定义类型到标准类型的转换函数，由于没有参数列表，也没有返回值类型，所以只有定义成类成员方法才能访问类成员变量。
    - **重载的赋值运算符** \
    由于赋值运算符的重载只能传入一个参数，所以也就限定了必须使得这个函数是一个成员函数才能访问被赋值对象的成员变量。

5. 有关函数的返回值类型：
    - 返回值类型是 const 的引用 \
    一个对象的引用表示的是这个对象本身，当返回值为一个对象的引用的时候可以等同的看成是返回了这个对象本身，因为没有产生新的对象，所以并不需要调用构造函数，所做的事情就变少了，也就提高了效率。当返回值是一个引用的时候，那么这个返回值就一定不能是这个函数里面的临时变量，因为一旦程序返回，这个临时变量就会被释放，故而这个返回值一定是来自入参，如果入参定义的是一个 const 的引用，那么这个返回值也必须是 const。
    - 返回值类型是非 const 引用 \
    对于引用部分，如上所述，至于非 const ，一是因为返回值是能够被修改的，非只读。二是因为传入参数本身就没有 const 属性。最常用的两个返回值非 const 引用类型的例子是赋值重载运算符和与 cout 共同使用的 >> 运算符重载。赋值运算符返回值为非 const 类型是因为这个值后续是可以被修改的。而 >> 运算符返回没有被声明为 const 是因为在 std 命名空间中的全局对象 cout 本身就不是 const 的。
    - 返回一个对象 \
    当返回的对象是在函数内部声明的自动变量，这个时候就应该返回是一个对象而非是一个引用，返回是一个对象的时候会在函数返回时产生一个临时变量来保存结果。
    - 返回一个 const 对象 \
    首先需要说明一点，当返回的是一个对象的时候会产生一个临时对象，并且这个对象一旦被使用了就会被丢弃，所以如果返回值类型是一个 const 的对象（非引用），意味着将产生一个 const 的临时变量，并且该变量是只读的，当完成赋值之后，这个 const 临时变量会被丢弃，所以被赋值的那个对象是没有任何影响的，照样能够被再修改。

    总而言之，如果返回的值是函数内的临时变量，那么应该返回的是一个对象，至于是否是 const 类型视情况而定，这个时候会调用复制构造函数来生成一个临时变量。
6. 必须在初始化函数里使用成员初始化列表来初始化的数据成员：
    - 非 static 的 const 成员。 \
    **const 类型的变量是要在创建的时候被初始化。** 因为这个成员是非 static 的，所以每一个对象都拥有一个这个 const 成员，并且是在构造函数调用的时候被创建。但是由于构造函数的执行流程是，在进入构造函数的大括号之前会为成员分配内存，然后进入大括号里面的函数开始执行，所以就导致了在为 const 对象分配内存的时候没有给这个对象赋值，也就没有被初始化。
    - 一个对象的引用 \
    **引用与 const 的特性是一样的，都是需要在创建的时候被初始化。** 
    
    所以上述两种情况下，都应该使用成员初始化列表来初始化成员。
    ```c++
    class Test{
        private:
            const int m_abd;
            another_class &m_item;
        public:
            Test(int abd,another_class &item);
    };
    Test::Test(int abd,another_class &item):m_abd(abd),m_item(item)
    {
        ...
    }
    ```
    **注意：** 
    1. 这种成员初始化列表的方法只能用于构造函数，绝不能用于构造函数以外的任何其他类方法；
    2. 非静态的 const 成必须使用这种方法初始化；
    3. 引用数据成员必须使用这种方法来初始化。



### 编译器会自动生成的函数
这些编译器可能会自动生成的函数又被称为特殊成员函数：
1. 默认构造函数\
    当程序员没有提供构造函数的时候编译器才会自动创建，如果显式定了一个构造函数，那么程序员需要手动添加默认构造函数。默认构造函数不接受任何参数（或者说要接受的参数都已经有了默认值）。需要注意的是，一个类，仅能有唯一一个默认构造函数。
2. 默认析构函数\
    
3. 复制构造函数
4. 赋值运算符
5. 地址运算符
6. 移动构造函数&emsp;（C++11特性）
7. 移动赋值运算符（C++11特性）

对于上述的特殊成员函数，如果程序员没有显式定义，编译器在使用到的时候会自动生成，其中
1. 默认构造函数\
    对生成的对象不做任何处理，成员数据的初始值未知。
2. 默认析构函数\
    对析构的对象不做任何额外处理。
3. 复制构造函数\
    逐成员赋值拷贝，仅拷贝值，即浅拷贝。
4. 赋值运算符\
    行为与复制构造函数相同。
5. 地址运算符\
    返回调用者的地址，即 this 指针值。