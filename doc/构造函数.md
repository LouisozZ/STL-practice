# 类构造函数
## 引言
为什么需要类构造函数？

对于一个有私有成员变量的类来说，怎么样给这些私有变量赋值是一个问题。首先一点，私有成员不能在外部被访问，所以想要通过类似初始化列表的方式来初始化类私有成员函数是不行的，这会违背私有特性，使用初始化列表就意味着是在外部直接访问一个对象的私有变量。那么还有一种方式就是通过成员函数，假如已经设计了初始化成员函数来对私有成员对象赋值，那么在调用任意需要操作私有成员变量的函数之前，都必须假设已经调用了初始化成员函数，否则对未初始化的变量进行操作，结果总是未知的。所以构造函数，就是一个在对象被创建的时候自动被调用的函数，可以用它来对对象进行初始化。

## 构造函数说明
**任何时候，只要对象被创建了，就一定会调用构造函数！！！**

不论构造函数的形式是怎样的，构造函数的函数名都是与类名相同，并且没有返回值，而且访问控制应该为 public ，这是因为构造函数是一个公用接口才能在外部被调用。所以一个构造函数最基本的样子应该是:
```c++
class MytestClass{
    public:
        MytestClass(/*parameter list*/);
        ...
};
MytestClass::MytestClass(/*parameter list*/)
{
    /* init code */
}
```
在设计成员函数的时候，需要注意的一点就是形参名字不能与类成员变量名字相同，这是因为在类的作用域中，成员变量是可以直接被使用的，示例如下：
```c++
class MytestClass{
    private:
        std::string name;
        int age;
    public:
        MytestClass(std::string input_name, int actual_age);
        //int changedata(std::string input_name, int actual_age);
        int changedata();
};
MytestClass::changedata()
{
    age = 24;
    name = "louis";
    return 0;
}
```
对于上述的成员函数，此时的 name 和 age 的意义是明确的，是类的成员变量，当一个对象被创建的时候，实际操作的就是调用这个成员函数的对象的成员变量。

可是如果现在调整了函数接口，有了入参，且形参的名字与类成员变量的名字相同，这个时候就不知道 name 和 age 分别指代的是什么了。
```c++
MytestClass::changedata(std::string name, int age)
{
    age = age;
    name = name;
    return 0;
}
```
即使上述的代码能正常运行，即运行不报错，实际产生的效果顶多就是不会对成员变量的值造成修改，可是如果构造函数也是如此，形参名字与成员变量名字相同，那么就会导致未初始化成员变量，或者甚至是更严重的错误。

所以综上所述，所有类成员函数的设计，其形参都不能与成员变量名相同（同理也不能与成员函数名相同），为此，也可以是在每个成员变量名字前加上前缀 **m_** 以此来说明该变量为成员（member）变量。
```c++
class MytestClass{
    private:
        std::string m_name;
        int m_age;
    ...
};
```
## 构造函数分类
### 默认构造函数
构造函数可以显式地被调用，也可以隐式地被调用。
```c++
class MytestClass{
    private:
        std::string m_name;
        int m_age;
    ...
    public:
        MytestClass(const std::string & name, int age){ m_name = name; m_age = age;};
    ...
};
int main()
{
    //显式调用构造函数
    MytestClass object1 = MytestClass("louis",24);
    //隐式调用构造函数
    MytestClass object2("louisister",14);
    //与 new 一同使用
    MytestClass *object3_ptr = new MytestClass("louisgf",18);
    ...
    return 0;
}
```
显式调用的时候直接调用构造函数名即可，因为类名会在整个程序的作用域中唯一，所以对应的构造函数也只有该类所持有的唯一一个，故而编译器是能够正确定位函数的。隐式调用是直接在声明的对象后面用括号加上参数列表就可以了。
> 有关于 **new** 的部分可以参考 [有关于new和delete.md](./有关于new和delete.md) 。

### 复制构造函数
12.5 
