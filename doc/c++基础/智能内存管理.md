# C++ 中的内存管理

<!-- TOC -->
- [C++ 中的内存管理](#c-中的内存管理)
  - [智能指针](#智能指针)

## 智能指针

对于常规指针而言，忘记释放内存的情况总是会出现，而且能够引起内存泄露的，就是找不到分配的内存空间了，也就是保存这块地址的指针本身被释放掉了，这种情况往往出现在栈帧被清理的时候（否则的话，指针的值是能够被拿到的，可以进行对其指向的内存的释放操作，所以不存在内存泄露）。所以如果一个动态内存分配的结果地址存放在某个栈帧上，一旦栈帧释放之前没有释放掉这块内存，那么就会造成内存泄漏。

所以智能指针的出现就是为了解决这个问题。首先来说说栈帧，因为栈帧的清理是自动进行的，不论是函数跳转、异常处理还是线程退出，都会自动清理栈帧来保证之后的程序正常运行。对于内置类型而言，栈帧的释放不会对其造成任何影响，只是其所在地址不能被访问而已（越界），但是对于自定义类型，也就是一个对象，如果所在栈帧即将被释放，那么会自动调用该对象的析构函数（new 定位运算符不算），所以只能指针的思想就是：**指针是一个对象，在其析构函数中对指向的内存进行释放。** 这样的话，只要栈帧被释放，那么其上的指针指向的内存就会被释放，就不会出现内存泄露了。

三种智能指针：

- auto_ptr  (已摒弃，不再讨论)
- unique_ptr
- shared_ptr
  
对于 unique_ptr 而言，它采用的方式是接管式的，整个程序的运行生命周期内，对于同一个智能指针，只能有一个拥有对象：

```c++
unique_ptr<double> ptr_1(new double(1.0));
unique_ptr<double> ptr_2;
ptr_2 = ptr_1;  //error!!! but for showing unique.
```

对于第三行的代码，首先这句是错的，但是可以用来说明这种接管方式。最开始的时候， ptr_1 是指向一个 double* 的指针，此时可以通过 *ptr_1 来访问这个 double 变量，也就是说，现在的智能指针是 ptr_1 ，当第三句执行了之后（假设可以执行），指向该 double 变量的智能指针就是 ptr_2 ，而不再是 ptr_1 ，此时通过 ptr_1 去访问 double 变量是错误的，因为 ptr_1 不再是一个智能指针了，这就是接管，只能有一个。其底层的实现是移交了指针的值，假设保存指针值的成员变量时 address，那么接管过程是：

```c++
ptr_2->address = ptr_1->address;
ptr_1->address = nullptr;
```

上述的赋值代码(非接管的底层代码)对于 auto_ptr 是没有错的，能编译通过，但是如果在后面的程序中一旦使用 *ptr_1 就会出错（段错误），但是对于 unique_ptr 来说，第三句是编译不通过的，编译器不允许有悬挂的 unique_ptr 对象存在，但是如果右值是一个临时对象，这种赋值是可以的，因为临时对象是会很快（立即）被释放的。

```c++
unique_ptr<double> ptr_1 = unique_ptr<double>(new double(5.0));
```

上述代码右式产生临时变量，可以被赋值给 ptr_1。如果右式是一个会存在一段时间的对象，这种赋值就会在编译阶段被阻止。

> unique_ptr 的数组版本：unique_ptr<double[]> ptr(new double [9]);

一个右值 unique_ptr 对象可以作为实参被传递到 shared_ptr 的构造函数中，但是左值 unique_ptr 却不行。

```c++
unique_ptr<double> l_ptr(new double(4.0));
shared_ptr<double> s_ptr1(l_ptr);    //error!!!
shared_ptr<double> s_ptr2(unique_ptr<double>(new double(1.0))); //right
```

[返回主目录](../../README.md)