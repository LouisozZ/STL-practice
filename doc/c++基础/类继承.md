# 类继承

当一个类是从另一个类继承而来的，那么新的类被称为派生类，而原来已有的类被称为基类。

首先介绍一个新的访问控制类型， **protected** ，是除 public 和 private 之外的另一种访问类型。protected 和 private 类型的区别仅限于继承之后派生类对基类中成员的访问控制权限。

首先对于非派生类中，即，该类并不是某一个类的基类，此时访问权限仅涉及到类中、类外。类成员（类中）对类中所有成员和方法都具有访问权限，类外的对象、方法，仅能访问类的公有成员函数以及数据成员。

如果该类是某一个类的基类，那么在派生类中，对于私有成员只能通过公有方法来访问，但是**对于 protected 属性的成员和方法，是可以直接访问的**。这也是 protected 属性与 private 属性的唯一区别。

熟悉了 protected 属性之后，来看用法，对于数据成员最好不要使用 protected 属性，因为这可能会破坏基类在设计时的数据权限：如果基类中有某个数据是使用的 protected 权限限制，此时仅类方法可以直接访问该数据，但是外部是无法访问的。可是一旦基类被继承了，在派生类中，是可以直接访问 protected 成员的，这时候原本只能通过基类公有方法访问的变量在派生类中是可以直接访问的，也就意味着是可以在派生类中直接修改这些保护变量的，这违背了基类中对该变量的设计初衷。但是利用这种特性，可以使用 protected 来限定基类中的函数，这样的话就可以在派生类中也能使用一些内部函数，同时又对外隐藏了这些接口。

总而言之，protected 属性可以使用在函数上，以此来向派生类开放内部函数；同时避免将 protected 属性用在成员变量上，避免在派生类中破坏了原本的设计。

## 公有派生

```c++
class DerivedClass : public BaseClass{
    ...
}
```

继承的部分有：

1. 基类的公有成员会成为派生类的公有成员；
2. 基类的私有部分也将成为派生类的一部分，但是只能通过基类的公有和保护方法去访问。

派生类需要做的事情：

1. 派生类需要编写自己的构造函数；
2. 派生类可以根据需要添加数据成员和成员方法。

公有派生而来的派生类和基类之间是 is-a 的关系，派生类继承了基类的接口，意思是派生类可以直接使用基类的公有方法。相较而言，如果是 has-a 的关系，是没有继承接口的，即通过派生类（或者是上层类）对象在外部是不能调用对应组件的公有方法，但是在类定义的内部是可以直接使用的（如果是包含成员对象，则是通过对应的对象来调用对应的公有接口）。

### 关于公有派生的构造函数

**注意：** 派生类的构造函数需要为基类的数据成员提供数据。

一个派生类的执行过程如下：

1. 创建一个新的派生类对象的时候先调用基类构造函数来初始化一个基类对象；
2. 进入派生类构造函数代码段，初始化新添加的类数据成员（如果有的话）。

```c++
//构造函数 1
DerivedClass::DerivedClass(int new_member,BaseClass &base_item)
{
    m_newmember = new_member;
}
//构造函数 2
DerivedClass::DerivedClass(int new_member,int base_member1, string base_member2):BaseClass(base_member1,base_member2)
{
    m_newmember = new_member;
}
//构造函数 3
DerivedClass::DerivedClass(int new_member,BaseClass &base_item):BaseClass(base_item)
{
    m_newmember = new_member;
}
```
上述代码中的第一种派生类构造函数，由于没有指定如何初始化基类成员，所以与下述代码等效：
```c++
DerivedClass::DerivedClass(int new_member,BaseClass &base_item)：BaseClass()
{
    m_newmember = new_member;
}
```
相当于我们在声明一个基类对象的时候没有进行初始化，这样的话，这个基类对象就会调用默认构造函数，那么实际上传入的 base_memberX 就没有被使用。

对于第二种派生类构造函数，指定了调用这样的基类构造函数来给基类对象初始化，但是这种方式的前提是基类实现了这样的构造函数。

第三种派生类构造函数是通过一个基类对象来进行初始化工作，从之前所学可知，这是类的复制构造函数，如果基类没有显式实现这种构造函数，那么编译器再用到的时候会自动生成一个浅拷贝版本的复制构造函数。

所以综上所述，一个派生类的构造函数在进入自己的逻辑之前一定会调用一个基类的构造函数，先初始化一个基类对象，然后再进入自己的逻辑里面初始化新添加的数据成员（如果有的话）。所以如果要析构一个派生类对象，析构的顺序是和构造的顺序相反的，首先会调用派生类的析构函数，然后再自动调用基类的析构函数。

有一点需要注意的是，一个派生类仅仅只能将数据传递给其相邻的基类。

```c++
class A{};
class B:public A{};
class C:public B{}'
```

对于上述情况，C 类的构造函数仅能将数据信息传递给类 B，而不能传递给类 A，不过类 B 可以将得到的信息继续向后传递给类 A 。

### 派生类和基类之间的关系

1. 派生类可以使用基类的方法，但是前提是这个方法不能是私有的；
2. 基类指针可以在不显式类型转换的情况下指向派生对象；
3. 基类引用可以在不显式类型转换的情况下引用派生对象。

不过基类的指针或者引用只能调用基类的方法，并且指向派生类的指针或者是派生类的引用是不能指向或者引用基类对象的（因为基类对象没有派生类的方法）。所以可以使用一个派生类对象来初始化一个基类对象：

```c++
DerivedClass devired_item;
BaseClass base_item(devired_item);
```

对于上述的代码，第二句对应的函数原型应该是

```c++
BaseClass::BaseClass(DerivedClass &);
```

实际上在设计类 BaseClass 的时候是没有这个函数原型的，但是却有复制构造函数原型如下：

```c++
BaseClass::BaseClass(BaseClass &);
```

此时函数原型形参类型为基类引用，而实际传入的实参类型是派生类引用，由于基类引用是可以引用派生类对象的，所以

```c++
BaseClass base_item(devired_item);
```

这句的调用是没有问题的。

同样的如果把一个派生类对象赋值给一个基类对象也是可以的，这个时候调用的就是基类重载的赋值运算符。

### 多态公有继承

主要说明了如何实现继承中接口的多态，虚函数的特点等。详细内容请查看文章 [C++的多态形式](./C++的多态形式.md) 中的多态公有继承小节。

### 关键字 virtual

由 virtual 关键字限定的方法是虚方法。

一个对象对应着一个类描述，对象调用了某一个方法，一定对应的是与其相关的类描述的那个方法。所以**一个对象本身（并非指针也非引用）对某一方法的调用一定是确定的，且一定是与其类声明中对应的方法一致。** 对于虚函数而言，引用或者指针执行的函数调用，实际调用的是所指向或引用的对象的方法；对于非虚函数，即使是引用或者指针，调用的也是引用或指针本身类型对应的方法。其中的原因是：**在 C++ 中，虚函数总是采用动态联编，非虚函数总是采用静态联编。其中动态联编实在运行时确定实际调用对象的类型，而静态联编是在编译阶段确定调用对象类型。** 所以对于非虚函数，由于在编译阶段确定的类型，故而只能调用指针或引用本身对应的类型中描述的方法。

**一种动态联编的方法：** 编译器为每一个对象都自动生成一个成员变量，该成员变量是一个指针，指向的是一个数组，这个数组的每一个元素都是函数地址，这个数组也就是虚函数表。一个类中声明了多少个虚函数，这张虚函数表就有多少个元素（在基类中声明为虚属性的函数在派生类中依旧是虚属性，且虚属性具有传递性），并且记录对应函数的地址。对于基类而言，直接能确定各个函数的地址，对于派生类而言，首先会继承从基类而来的虚函数表，当派生类中重新定义了某个虚函数，其对应的虚函数表项就会被修改为新的地址。在运行时，会根据虚函数表，去实际的地址调用函数。上述产生虚函数表，修改虚函数表以及运行时确定函数的过程就是动态联编。

**虚函数的注意事项**

1. **构造函数不能是虚函数。** 由于派生类会有新的类名，并且派生类的对象调用的自己的构造函数，在进入函数体之前会调用基类的构造函数，这两个函数是分开的独立函数，所以将构造函数声明为虚函数没有任何意义，并不会重新被定义。
2. **基类的析构函数应该是虚函数。** 当使用基类指针或引用来指向或者引用派生类对象的时候，如果析构函数不是虚函数，那么调用的析构函数将是基类的析构函数，如果派生类中使用了 new 运算符来为新的成员对象分配空间，那么将会导致内存泄漏。并且即使这个类不用做基类，声明一个虚析构函数也是没有错误的，仅仅是效率相比静态联编会有所降低而已。
3. **友元不能是虚函数。** 虚函数只能是类成员函数，而友元并非是类成员。
4. **如果虚函数没有在派生类中重新被定义，那么派生类将使用基类的虚函数版本。** 如果该派生类实在派生链中，那么将使用最新版本的基类虚函数（在该派生类之前的类都是其基类-个人理解）。
5. **如果在派生类中重新声明了虚函数，即函数原型不相同，那么新版本的函数将隐藏旧版本函数**，示例：
   
   ```c++
    class BaseClass{
        public:virtual BaseClass& function(int a); 
    };
    class DerivedClass:public BaseClass{
        public:DerivedClass& function();
    };
    int main()
    {
        DerivedClass item;
        item.function();    //right
        item.function(3);   //error!!!
    }
   ```

   新的不接受任何参数的 function 将隐藏基类中接受一个 int 类型参数版本的 function ，隐藏表示的是没有产生两个函数，没有发生重载。从虚函数表的角度去理解，也就是一个函数名对应了一个虚函数表表项，而与特征标（参数列表）无关，此时检测到这个地址的函数是没有参数的，所以会报错。因此**如果需要在派生类中重写函数，那么应当保证函数原型相同。** 不过如果基类虚函数返回类型为基类的引用或指针，那么在派生类中，返回值类型是可以修改为派生类的引用或指针的，如上所示。
6. **如果基类中虚函数被重载了，那么应该在派生类中重新声明所有的重载版本（即使只会重新定义其中一个版本的函数）**，否则的话会出现跟 5 相同的情况，会隐藏别的重载版本的函数。

## 私有派生

私有派生出来的是一种 has-a 的关系，与公有派生的 is-a 关系不同，没有继承基类的接口，在外部不能通过派生类对象直接调用基类的公有接口。不过在类声明和定义内部是可以直接调用基类的公有接口的。

私有派生时，基类的公有和保护成员、方法都会变成派生类的私有成员。

跟公有继承一样，如果要**使用基类的公有方法，可以使用作用于解析运算符限定(如函数Average)**；如果要**使用基类组件（后面叫子对象）本身，那么就需要进行显式强制类型转换。(如函数operator<<)**

```c++
class DerivedClass:private std::string, std::valarray<double>{
    typedef std::valarray<double> ArrayDB;
    public :
        friend std::ostream & operator<<(std::ostream &, const DerivedClass &);
        double Average() const;
    ...
};
std::ostream &operator<<(std::ostream & os, const DerivedClass &input)
{
    os << (const std::string &)input;
}

double DerivedClass::Average() const
{
    if( ArrayDB::size() > 0)
        return ArrayDB::sum()/Array::size();
    else
        return 0;
}
```

同样可以产生 has-a 关系的一种方式是包含类成员对象，即一个类的某个(些)成员是另一个类的对象，这样的关系被称为包含。包含与私有继承一样，是不继承接口的，对子对象公有方法的访问只能通过子对象的调用来完成。

包含和私有继承的区别：

1. 包含通过子对象访问其公有方法；私有继承通过作用域解析运算符访问公有方法；
2. 包含可以通过子对象名直接访问子对象；私有继承通过强制类型转换访问子对象；
3. 包含无法直接访问子对象的保护成员；私有继承可以直接访问基类的保护成员；
4. 包含只能是使用一个累，而无法重新定义子对象的虚函数；私有继承可以重新定义基类的虚函数。

**总结：通常应该使用包含来建立 has-a 的关系，但是如果需要使用基类的保护对象，或者是需要重新定义基类的虚函数，则应该使用私有继承。**

## 保护继承

在保护继承的情况下，基类的公有和保护成员都会变成派生类的和保护成员。

**隐式向上转换：** 无需显式进行类型转换就能使用基类指针或者引用指向派生类对象。

各种继承关系表

| 特征|公有继承|保护继承|私有继承|
|-|-|-|-|
| 公有成员变成 |派生类的公有成员|派生类的保护成员|派生类的私有成员|
| 保护成员变成 |派生类的保护成员|派生类的保护成员|派生类的私有成员|
| 私有成员变成 |只能通过基类接口访问|只能通过基类接口访问|只能通过基类接口访问|
| 能否隐式向上转换|是|是（但只能在派生类中）|否|

## 抽象基类ABC (abstract base class)

### 纯虚函数

当我们在头文件的类声明中声明一个函数，往往还需要在源文件中为对应的函数书写定义，否则会编译报错 "未定义的引用" ，虚函数也是如此。不过如果在虚函数声明的末尾加上 "=0" ，可以将该虚函数声明为纯虚函数，向派生类提供未实现（定义）的函数接口。值得注意的是，**一旦一个类声明中包含了虚函数，那么这个类就不能创建对象，包含了纯虚函数的类只能用做于基类。**

ABC是至少包含一个纯虚函数的类。然后可以通过将 ABC 作为基类来派生出派生类，派生类中需要对纯虚函数进行定义，然后才可以创建对象。此时可以用 ABC 的引用或指针数组来管理从 ABC 派生出来的类对象。

## 多重继承

当一个类的基类有多个的时候，就会出现多重继承现象。

```c++
class DerivedClass:public BaseClass1, public BaseClass2
{
    ...
}
```

在这种情况下，会在 DerivedClass 类中产生两个基类组件，一个是 BaseClass1 子对象，一个是 BaseClass2 子对象。那么如果此时的 BaseClassX 都是继承自同一个基类 BaseBase，会出现什么情况呢？（也就是多重继承的时候，不同组件最终指向的是公共祖先）

```c++
class BaseClass1:public BaseBase{ ... };
class BaseClass2:public BaseBase{ ... };
```

那就是在 DerivedClass 类中，会有两个内容相同的 BaseBase 子子对象，分属于不同的 BaseClass1 子对象中和 BaseClass2 子对象中。当需要使用一个基类指针或者引用来指向 DerivedClass 对象的时候(隐式向上类型转换)，会出现二义性，此时不知道该指向哪个子对象中的子子对象，所以如果确实需要指定的话，应该明确指出使用哪个子子对象：

```c++
DerivedClass item;
BaseBase &ref1 = (BaseClass1 &)item;
BaseBase &ref2 = (BaseClass2 &)item;
```

虽然这样没有错，但是却给程序设计造成了麻烦，并且两个相同内容的对象本来就是冗余。可以通过虚基类的方式来消除这种冗余：

```c++
class BaseClass1:virtual public BaseBase{ ... };
class BaseClass2:public virtual BaseBase{ ... };
```

通过在继承的时候声明该继承为虚继承来使得对应的基类变成虚基类。 virtual 关键字和继承类型关键字的位置没有规定。通过这种方式，DerivedClass 继承自 BaseClass1 和 BaseClass2 的时候就只有一个 BaseBase 组件了。

但是虚基类会导致一些问题，首先是构造函数不再具有传递性。没有虚基类的时候，构造函数的数据是可以逐层传递的：

```c++
class A{
    private:
        int m_int;
    public:
        A(int x):m_int(x){};
};
class B:public A{
    private:
        double m_db;
        std::string name;
    public:
        B(int x,double db,string &input):A(x),m_db(0.0),name(input){};
};
class C:public B{
    private:
        char m_c;
    public:
        C(int x,double db,string &input, char c):B(x,db,input),m_c(c){};
};
```

但是如果使用了虚基类，那么要初始化 BaseBase 组件的时候就会出现问题，现在只有一个虚基类组件，执行下述代码时：

```c++
DerivedClass::DerivedClass(...):BaseClass1(...),BaseClass2(...)
{
    ...
}
```

在成员初始化列表中初始化 BaseClass1 的时候会初始化 BaseBase 组件，初始化 BaseClass2 的时候会初始化 BaseBase 组件，也就是说初始化 BaseBase 组件的有两条路径，为了避免这种冲突，当基类是虚的时候，C++ 禁止通过中间类来传递参数给基类。这个时候需要显式调用基类的构造函数来执行基类 BaseBase 的初始化。

```c++
DerivedClass::DerivedClass(...):BaseClass1(...),BaseClass2(...),BaseBase(...)
{
    ...
}
```

**注意！上述做法对于虚基类是必须的，要么使用基类的默认构造函数，要么显式调用基类的构造函数。但是对于非虚基类的情况，上述做法是非法的！！！如果一个类有间接的虚基类，除非使用默认构造函数，否则必须显式调用虚基类的构造函数。**

故而当使用了虚基类的时候，可能会需要修改已有代码。

接下来还有一个问题，如果在 BaseClass1 和 BaseClass2 中都定义了一个同名但是实现不同的方法，这个时候 DerivedClass 对象调用的时候应该怎么调用呢？一种方法是使用作用域解析运算符来指定调用的是哪个组件中的方法。但是这种方法会给使用者带来不便：

```c++
DerivedClass item;
item.BaseClass1::show();
item.BaseClass2::show();
```

使用者需要两次调用，并且还需要知道继承自哪些类。所以另外还有一种方法就是在 DerivedClass 类中将上述两个方法重新定义，由类设计者完成这种选择，并且提供更好的接口。**这也就引出了一个结论，在有虚基类的继承链中，对于每个组件，都只负责自己组件的各个工种（实际上也应该如此，因为公共基类已经单独出来，不再是一个中间类一个副本了），然后再使用接口拼接起来。**

当一个类即从虚基类继承同时也从非虚基类继承，此时对于从虚基类继承的组件共享同一个虚基类组件，而非虚基类继承则分别各自有一个基类组件。

## 继承与动态内存分配

### 派生类中没有使用动态内存分配

如果仅仅是基类中使用了动态内存分配，那么派生类的析构函数和赋值运算符都可以使用编译器提供的默认的。

对于析构函数来说，由于派生类中没有动态内存分配，所以在析构的时候不需要进行 delete ，并且派生类的析构函数在执行完本身的析构代码之后会调用基类的析构函数，所以只需要基类中的析构函数正确释放内存即可；

对于赋值运算符来说，编译器会根据等号两边数据的类型来选择使用那个赋值运算符，所以只要基类重载了赋值运算符，在派生类中，即使是默认重载的赋值运算符是浅拷贝，但是实际调用的是基类重载之后的赋值运算符，是没有问题的。

同样的道理，对于复制构造函数来说，是逐成员赋值的，由于没有使用动态内存分配，所以是没有问题的，而对于一些对象成员（如基类组件），由于所属类本身重载了赋值运算符，所以使用默认的复制构造函数就可以。

对于构造函数来说，还是跟之前所提及的一样，需要使用初始化成员列表来为基类的数据成员提供初始化数据。

### 派生类中使用了动态内存分配

其实这种情况跟任何一个类中使用了动态内存分配的处理方式是一样的，需要显式的定义复制构造函数，析构函数，重载赋值运算符。只不过派生类只负责新添加成员的内存管理。

对于构造函数来说，仍然是需要使用成员初始化列表来向基类组件提供初始化数据。

对于复制构造函数来说，需要重新分配一块内存来保存数据。**（另外提一点，对于所有的构造函数，都应该为基类的初始化提供数据，特别的，对于复制构造函数来说，由于传递进来的是一个派生类的引用，这个时候可以直接将这个形参作为实参，在成员初始化列表中传递给基类的复制构造函数，因为基类的引用类型是可以引用派生类对象的，并且在基类的赋值构造函数中，只会复制属于基类的部分）**

对于析构函数，仅需要释放在派生类构造函数中分配的内存即可，剩下的则由基类的析构函数来完成。

**比较特殊的是赋值运算符的重载。基类的赋值运算符完成了有关基类数据的赋值操作，包括释放原内存空间，创建新内存空间，拷贝等操作。而派生类的赋值运算符不仅要负责完成新添加成员的赋值，还需要负责显式完成基类组件的赋值操作，但是由于这个操作在基类中已经完成了（其实由于不能直接操作基类的私有成员，所以还是得通过接口来完成这个显式的赋值操作），应该调用基类的赋值运算符来完成基类组件的赋值过程。在派生类中，要访问基类对象组件，只能通过派生类对象才可以，因为基类对象是嵌套在派生类对象中的，所以如果在赋值运算符重载的函数体里面直接使用　"＝"　，那么　"＝"　两边的操作数都是派生类类型，这个时候会形成对派生类作用于中重载的等号的递归调用，从而出错。** 正确的做法是显式调用基类的赋值运算符，并且使用函数调用的形式：

```c++
DerivedClass & DerivedClass::operator =(DerivedClass &item)
{
    ...
    BaseClass::operator=(item);
    ...
}
```
上面的　BaseClass::operator=(item);　就是对基类中重载的赋值运算符的显示调用，该句等同于:

```c++
    *this = item;　//invoke BaseClass::operator =()
```

### 派生类中的基类友元函数调用

首先需要明确一点，当多个类重载了同名友元函数，实际上是发生的重载，每个版本的特征标是不同的，所以如果需要使用特定版本的重载函数的时候，应该确保本次调用的特征标与预期调用版本的特征标是相同的。

拿 "<<" 运算符举例，该运算符的第一个参数是　std::ostream　，第二个参数是自定义类型，此时要是在派生类使用基类中该运算符的重载，应该将类型转换为基类类型：

```c++
std::ostream& operator >>(std::ostream &os, const BaseClass &base_item)
{
    ...
}

std::ostream& operator >>(std::ostream &os, const DeviredClass &derived_item)
{
    ...
    os << (const BaseClass &)derived_item;  //此时的特征标会匹配基类中的重载版本，就不会调用当前版本的重载了。
    ...
}
```

## 小知识点

### 1、 关于成员初始化列表

如果一个类的成员数据是一个对象，由之前的学习可知，在类声明的时候是没有真正分配内存空间的，所以是没有一个真实对象产生的，直到用这个类声明来产生一个真是对象的时候，才会真的给其成员变量分配内存空间，才会产生成员对象。所以如果一个类：

```c++
class Test{
    private:
        Memberclass1 m_item1;
        Memberclass2 m_item2;
        ...
    public:
        Test(Memberclass1 &item1, Memberclass2 &item2);
};
Test::Test(Memberclass1 &item1, Memberclass2 &item2)
{
    m_item1 = item1;
    m_item2 = item2;
}
```

如果构造函数如上所示，那么这个构造函数的调用过程如下：

1. Test 对象的声明语句调用构造函数 Test(Memberclass1 &, Memberclass2 &),但是由于需要先产生一个 MemberclassX 对象用于被赋值，所以在进入该构造函数的左大括号之前首先会调用 MemberclassX 的默认构造函数，生成对象 m_itemX。
2. 然后进入 Test 的构造函数中调用 MemberclassX 的赋值运算符函数，为对象成员变量赋值。

不过如果构造函数是使用**成员初始化列表**的方式来对成员进行初始化的：

```c++
Test::Test(Memberclass1 &item1, Memberclass2 &item2)
:m_item1(item1),m_item2(item2)
{}
```

**那么 Test 构造函数会在进入大括号之前，调用 MemberclassX 的复制构造函数直接初始化 m_itemX 。**

上面仅提到了在成员初始化列表中使用复制构造函数，其实是可以使用任意**已定义**的构造函数。**这里有一点是值得注意的，那就是成员初始化列表中小括号前的内容。** 对于一个派生类来说，他的构造函数的成员初始化列表中使用的是**类名**，也就相当于是直接调用的基类构造函数。但是对于类成员是另一个类的对象的时候，此时构造函数的成员初始化列表中使用的是**成员变量名**，如上面代码中那样，但是实际的过程是：根据变量名后面括号中的参数，来寻找该变量类型中有相同特征标的构造函数，调用该构造函数来初始化这个成员变量。

**初始化顺序：** 对于一个类，如果他是继承于某一个基类，那么在执行派生类的构造函数之前会创建好基类的嵌套对象；同理，如果一个类中有别的类的成员，那么在执行外层类的构造函数之前也应该首先创建好成员对象。所以综上所述，凡是需要在构造函数执行之前创建的都应该添加到初始化成员列表中。但是实际的初始化顺序只与类声明中的顺序有关，而与初始化成员列表中的书写顺序无关，即初始化顺序是类中的声明顺序。

[返回主目录](../../README.md)