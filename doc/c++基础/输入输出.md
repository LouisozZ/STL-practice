# 输入输出

<!-- TOC -->
- [输入输出](#输入输出)
  - [输出](#输出)
    - [别的 ostream 方法](#别的-ostream-方法)
    - [刷新缓冲区](#刷新缓冲区)
    - [格式化 cout](#格式化-cout)
  - [输入](#输入)
    - [流状态](#流状态)
    - [其他 istream 类方法](#其他-istream-类方法)
    - [其他 istream 方法](#其他-istream-方法)
  - [文件输入输出](#文件输入输出)

与输入输出相关的类组成：

- streambuf 类**为缓存提供了内存**，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法；
- ios_base 类**表示流的一般特征**，如，是否可读取，是二进制流还是文本流等；
- ios 类基于 ios_base，其中包含了一个指向 streambuf 对象的指针成员；
- ostream 类是从 ios 类派生而来，提供了输出方法；
- istream 类也是从 ios 类派生而来，提供了输入方法；
- iostream 类是基于 istream 和 ostream 的，继承了输入方法和输出方法。

在程序中包含 iostream 文件，将回自动创建 8 个流对象，四个用于窄字符流，四个用于宽字符流：

- **cin** 对象对应于标准输入流。在默认情况下，这个流被关联到标准输入设备（通常为键盘）。**wcin** 对象和 cin 类似，不过处理的是 wchar_t 类型。
- **cout** 对象对应于标准输出流。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。**wcout** 对象和 cout 类似，不过处理的是 wchar_t 类型。
- **cerr** 对象对应于标准错误流。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。**这个流没有缓冲，信息会被直接发送到屏幕，而不会等待缓冲区填充满一个块（512B）或者有新的换行符填充到缓冲区**。**wcerr** 对象和 cerr 类似，不过处理的是 wchar_t 类型。
- **clog** 对象也对应于标准错误流。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。**这个流会被缓冲**。**wclog** 对象和 clog 类似，不过处理的是 wchar_t 类型。

## 输出

ostream 类对 C++ 的**所有基本类型**都提供了 `operator<<()` 函数的定义，只要是基本类型，cout 都可以将其转换为合适的数值字符串输出到标准输出（或者重定向的目标输出）。

对于指针，对下面的类型提供了 `operator<<()` 的函数定义：

- const signed char\*
- const unsigned char\*
- const char\*
- void\*

前三种，都是可以输出以 `'\0'` 结尾的字符串，而最后一种是输出逻辑地址。所以如果对于一个变量，或者是指向一个字符串的指针，要是想知道他们的逻辑地址，那么应该转换为 `void*` 类型再使用 cout。

### 别的 ostream 方法

|方法|说明|例程|
|-|-|-|
|ostream& put(char)|显示一个字符|`cout.put('o').put('k')`|
|basic_ostream\<charT,traits\>& write(const char_types \*s, streamsize n)|从地址 s 的地方输出 n 个字符|`cout.write("this is a",4)`|

### 刷新缓冲区

输入输出都是有缓冲区的，如前面所述，是有 streambuf 来管理，当我们输出的时候，一般是先将要输出的内容输出到缓冲区里面，当：

1. 有换行符到达缓冲区；
2. 有等待的输入动作；
3. 缓冲区内字符达到一定值；

上面的三种情况发生的时候，就会将当前缓冲区的内容发送到目标输出上，不过我们可以手动刷新缓冲区。

```c++
//1.单纯的刷新缓冲区内容到目标输出，并清空缓冲区
flush(cout);
//2.刷新缓冲区，并且会输出一个换行符
cout << ... << endl;
//3.单纯的刷新缓冲区内容到目标输出，并清空缓冲区
cout << ... << flush;
```

### 格式化 cout

第一个是 **修改输出的进制** 。有两种方法可以修改输出的进制体现，**输出进制的修改是持久的**，直到下一次修改输出进制：

```c++
//方法一，使用 <<
cout << hex << your_value;
//or
cout << hex;
cout << your_value;

//方法二，使用函数
hex(cout);
cout << your_value;
```

其中进制相关的函数有：八进制 `oct()`，十进制 `dec()`，十六进制 `hex()`。

第二个是 **调整字段宽度** 。对字段的宽度调整是一次性的，当下次使用了调整了的字段宽度之后，会自动调整回默认的字段宽度 0。对于默认字段宽度为 0 需要做一些说明，在 C++ 中，如果字段宽度小于输出的数值宽度，那么会扩展字段宽度等于输出数值宽度，这也是我们经常使用的默认宽度。

```c++
cout.width(10);
cout << value1 << '#' << value2 << endl;
//上述两行代码，只会影响到 value1 的输出字段宽度至少为 10，而到输出 value2 的时候，又自动变成了 0
```

第三个是 **填充字段** 。默认的填充字段是空格，就好比我们设置了下一次输出的字段宽度是10个字符宽度，但是实际的值只有两个字符宽度，那么就会填充 8 个空格。我们可以通过使用成员函数 `fill(char)` 来改变填充字符。**对填充字符的修改是持续的，直到下一次被改变为其他。** 

```c++
cout.fill('*');
cout.width(10);
cout << value << endl;
//********26
```

## 输入

通常是按照如下方式使用 cin：

```c++
cin >> value_holder;
```

其中 value_holder 是存储输入的内存单元，可以是 **变量** ，**引用** ，**被解除引用的指针** ，也可以是 **类** 或者 **结构体的成员** 。cin 解释输入的方式取决于 value_holder 的类型，istream 类重载了对应数据类型的 >> 运算符，使之能够识别下面的这些基本类型：

- signed char &
- unsigned char &
- char &
- short &
- unsigned short &
- int &
- unsigned int &
- long &
- unsigned long &
- long long & (C++11)
- unsigned long long &
- float &
- double &
- long double &

上述都是引用类型，是因为这样的话，操作的就是对应的变量本身，而不是形参副本。

控制符 hex,oct,dec 可以与 cin 一起使用，指明当前输入的格式是哪种进制的。

```c++
cin >> hex >> data;
```

上面的是输入数值类型，istream 还为字符指针类型重载了 >> 运算符：

- signed char \*
- char \*
- unsigned char \*

对于这种类型的参数，cin 将从输入流中读取下一个单词，**加上一个空值字符 '\0'**，放置到指定的地址，成为一个字符串。

不论是数值输入还是字符串输入，亦或者是单个字符的输入（char,unsigned char,signed char），cin 检查输入流的方式都是一样的：

**跳过空白，直到遇到非空白字符。** 空白字符包括：`空格`，`换行符`，`制表符`。

也就是说，如果是 cin>>my_char; 如果此时从屏幕输入 `空格+回车`，my_char 的值是不等于空格的。但是 C 语言中的 scanf 却不是，如果是 `scanf("%c",&my_char);` 此时输入 `空格+回车`，那么 my_char 就是空格。

对于非单字符输入，cin 会读取从非空白字符开始，到与目标类型不匹配的第一个字符之间的全部内容。

那读取到非目标类型的字符的时候会发生什么呢？还有什么其他情况下会导致读取不到目标类型数据呢？

### 流状态

流状态在 ios_base 类中被定义为 iostate 类型，这是一种 bitmask 类型，流状态由 3 个 ios_base 成员组成，eofbit、badbit、failbit，每个元素都是一位。

|ios_base 成员|描述|
|-|-|
|eofbit|读取输入流的时候到达文件尾，该成员被设置成 1|
|badbit|当流被破坏的时候，该成员被设置为 1，。例如文件读取错误|
|failbit|如果输入操作未能读取到期望类型的字符，或者输出操作没有写入期望类型的字符，该成员被设置为 1|
|goodbit|流状态值为 0，即前面三种都是 0，这是另一种表示 0 的方法。|
|good()|成员方法，如果三种状态位都为 0，则返回 true|
|eof()|如果 eofbit 被设置，返回 true|
|bad()|如果 badbit 被设置，返回 true|
|fail()|如果 badbit 或者 failbit 被设置，返回 true|
|rdstate()|返回流状态(read state)|
|exceptions()|返回一个位掩码，指出哪些标记导致异常被引发|
|exceptions(iostate ex)|设置哪些状态可以导致 clear() 函数将引发异常|
|clear(iostate s)|其中 s 的默认值为 0，该函数将流状态设置为 s，如果 (rdstate() & exceptions()) != 0，引发异常 basic_ios::failure|
|setstate(iostate s)|调用 clear(rdstate()\|s)，设置 s 流状态位，其他状态位保持不变。|

上面的内容中，需要注意的一点是，`clear(iostate s)`，从字面意思是清除 s 状态，可是实际意义是将当前流状态设置为 s，s 没有涉及到的状态会被清空。并且 `setstate(iostate s)` 是将 s 状态置 1，其余状态不变。

**关于 exceptions() 和 exceptions(iostate)** ，其中不带参数的版本相当于是读取当前的设置，返回状态清零时会引发异常的状态位；而带参数版本则是设置，设置指定的状态位，当它被清零的时候触发 basic_ios::failure 异常。具体的过程就如 clear() 里面的所描述的：

> 如果 (rdstate() & exceptions()) != 0，引发异常 basic_ios::failure

```cpp
#include <iostream>
#include <exception>

int main(){
    using namespace std;
    cin.exceptions(ios_base::failbit);

    int value;
    int sum = 0;
    
    try{
        while(cin>>value){
            sum += value;
        }
    }catch(ios_base::failure & bf){
        cout << bf.what() << endl;
    }
    return 0;
}
```

上述代码中的异常捕捉会在输入的字符是非数字的时候发生。但是设置异常应该视情况而定，例如上面的这种方式就是不合理的，因为这不算是异常，异常是用于捕捉不正常的以外情况，而这里仅需要用 while 判断当前是否读到的了正确的字符就行了。不过设置异常也有其用武之地，例如从文件读取数据的时候，就可以为 badbit 和 failbit 设置异常，因为在从文件读取，除非出错，否则是不会出现上面的状态位被置位的（读取到文件尾是 eofbit 被置位）。

为什么可以写 `while(cin >> value)` 来判断当前是否读到正确数据呢？其实 `cin >> value` 相当于是调用 `cin.operator>>(value);` 实际上是对象 cin 的成员函数 operator>> 的调用，该函数在读取到与目标匹配的字符时候会执行转换并返回 true，如果读到了与目标类型不匹配的字符，返回 false。

当 `while(cin >> value)` 不满足条件之后，可以通过上面的 `eof()`、`bad()`、`fail()` 成员函数来判断究竟是什么原因导致了不满足测试条件。

```c++
while(cin >> value){
    sum += value;
}
if(cin.eof())
    cout << "end of file" << endl;
```

**注意！！！设置流的状态位会导致对后面的输入或输出关闭，直到状态位被清除！！！** 并且即使流的状态位被清除了，但是输入缓冲区里面的数据仍然存在，下次如果直接读取，那么读到的就是当前缓冲区里面剩余的数据。所以要想完全更新输入，那么还要将无效字符清理掉。

```c++
//清理策略 1：清理掉当前输入队列中的第一个无效数据
while(!isspace(cin.get()))
    continue;
//清理策略2：清理掉当前输入队列中的一行数据，不仅仅是一个单词
while(cin.get() != '\n')
    continue;
```

一般来说，当输入的字符与目标不匹配的时候，cin 的 failbit 会被置位，但是仅仅通过 `cin.fail()` 来判断当前的字符输入不匹配目标类型是不够的，由于历史原因，当到达文件尾的时候，fail() 也会返回 true。所以我们在判断的时候是需要注意的。

上述代码中的 `isspace()` 函数是判断参数是否是空格、制表符、换行符，如果是则返回 true，否则返回 false。

### 其他 istream 类方法

（1）**单字符输入**

单字符输入有三种方法：

- cin >> char_value;
- cin.get(char_value);
- char_value = cin.get();

不过，使用 cin 会跳过空白符，而 get() 会接收所有字符。get() 有两个版本，一个是 `int get(void)`，一个是 `istream & get(char &c)`，使用例程如下：

```c++
//例程 1：使用 char 类型来接收 cin.get() 的返回值
char ch_char;
ch_char = cin.get();
//例程 2：使用 int 来接收 cin.get() 的返回值，这种情况下可以将返回值用于判断是否到达文件尾，EOF 是一个常量
int ch_int = cin.get();
if(ch_int == EOF)
{
    ...
}

//例程 3：使用 cin.get(char &)
while(cin.get(ch_char)){
    ...
}

//例程 4：cin.get(char &) 的联接
cin.get(ch_char).get(ch_char).get()
```

对于第一个和第二个例程来说，使用 int 类型或者 char 类型来接收 cin.get() 的返回值都可以，因为 `int get(void)` 版本的单字节接收函数会将接收到的字符转换成其 ASCII 码值作为返回值返回，所以使用 char 类型来接收，是没有问题的。为什么不直接使用 char 作为其返回值，是因为还要有能够表现 EOF 常量的数值，char 类型的变量是没有办法跟常量进行数值比较的。

对于例程 3，`istream & get(char &)` 版本，返回的是 cin 本身，并且当缓冲区里面的数据是有效的时候，会修改参数指定的变量为当前有效的数据值，返回 cin 本身，继续执行后面的；当遇到了文件尾或者是由键盘键入的 CTRL+D、CTRL+Z 所产生的软件表示的文件尾，那么不会修改参数指定的变量，并且会设置 failbit 流状态，使得检测返回的 cin 结果是 false。

例程 4 说明了两个版本的 get() 之间的区别，返回 istream& 类型的版本是可以联接的，但是返回值类型为 int （也不一定是 int 类型，根据字符集可能还有更宽的类型）的，不能联接，但是可以更在最后一个 cin 后面。

（2）**字符串输入** 

```c++
istream & get(char*, int, char);
istream & get(char*, int);
istream & getline(char*, int, char);
istream & getline(char*, int);
```

这四个函数的第一个参数都是保存输入的内存地址（要分配足够的内存，否则会发生段错误）；第二个参数都是要读取的字符数+1，+1 是因为要留出一个字符的位置来存放字符串结束符 '\0'；三个参数版本的第三个参数是分界符，两个参数的版本分界符就是换行符。

读取一行字符串停止的规则：

1. 已经读取了第二个参数所指定的字符数（减 1 ）；
2. 在读到指定数目字符前，读取到分界符字符；
3. 到达文件尾；
4. 出错；

**get() 的字符串读取版本，与 getline() 相比，只有一个不同点，就是对最后分界符的处理方式。get() 的字符串读取版本会将分界符留在输入缓冲中，后面的输入操作，首先看到的是留在输入流缓冲中的分界符；而 getline() 则是将分界符从输入流中同有效数据一并取出，并且会丢掉分界符，下次输入操作的时候，看到的就是分界符后面的一个字符**。

（3）**忽略字符** 

```c++
istream& ignore(int = 1, int = EOF);
```

第一个参数是要从输入流缓冲区中忽略（实际效果就是跳过删除了）的字符数，第二个参数是分界符。该函数会读取并忽略第一个参数指定的字符数，或者直到遇到指定的分界符就停止，分界符也会被忽略掉。

（4）**字符串输入时候的意外**

已经知道了输入字符串有两种方法：`cin.get(char*,int)` 以及 `cin.getline(char*,int)`。有三条准则对这两种方法都适用：

1. 遇到文件尾，eofbit 被设置；
2. 流被破坏，例如设备故障，badbit 被设置；
3. 不能抽取字符的时候，将空值字符 '\0' 放置到第一个参数里面，并且使用 setstate() 设置 failbit 位。

前两点好理解，对于第三点，什么时候不能抽取出字符呢？

- 对于 get 方法，第一种情况是取一行字符的时候 **直接遇到文件尾**，这种情况下抽取不到字符；此外 get 还有一种情况无法抽取字符，就是 **遇到空行**。遇到空行的时候，`get(char*, int)` 设置 failbit，并且空行的换行符会被留在输入流中，这时候如果使用 `cin.get(char&)` 能够获得该换行符，当然，如果使用 `cin>>` 会跳过这个空白符。
- 对于 getline 方法，取一行字符的时候 **直接遇到文件尾**，仅这种情况下 getline 不能抽取到字符；遇到空行的时候，getline 会抽取出该换行符并且丢弃，此时第一个参数的第一个字符同样是 '\0' ，并且由于输入流中的换行符已经被抽取了，所以输入流中没有了空行的换行符。

### 其他 istream 方法

1. **`istream& read(char*, int)`** ：参数意义同 getline 相同，不过 read 相较于 getline 和 get(char*, int) 而言，不会在读取字符末尾加上空值字符，所以就不会把数据转换成字符串，常结合 ostream 中的 write 成员使用，用于文件输入输出。`cin.read(sentence,255);`
2. **`char peek()`** ：返回但是不抽取输入流中的下一个字符。`ch = cin.peek();`
3. **`istream& putback(char)`** ：将一个字符插入到输入流，下一个输入操作读到的第一个字符就是这个最后插入的字符。`cin.putback(ch);`

## 文件输入输出



[返回主目录](../../README.md)