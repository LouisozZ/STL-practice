# 序列式容器

## vector

头文件 `#include<vector>`

vector 是一个"数组"，与 c++ 内建的数组类型 array 都是管理一片连续的地址空间，他们的区别在于 vector 是动态变化的，会自动扩展大小；而 array 是静态大小，需要在声明时指定数组大小，并且后续如果需要扩展，是需要程序员来实现 "新分配内存-拷贝数据-归还旧内存" 整个完整过程。

### vector 的数据结构：

```c++
template<typename T>
class vector{
    ...
    protected:
        iterator start;             // 当前有效数据域起始位置 
        iterator finish;            // 当前有效数据域终止位置（最后一个有效元素后面的位置，这是一个哨兵位） 
        iterator end_of_storage;    // 当前整个 vector 的总空间尾 
};
```

### 接口介绍：

1. 构造函数
   1. **vector()** ：默认构造函数，新的容器空间大小为 0；
   2. **vector(size_type n,const T& value)** ：新的容器大小为 n ，每一个元素都初始化为 value；
   3. **explicit vector(size_type n)** ：新的容器大小为 n，每一个元素都调用其所属类型的默认构造函数；
2. 迭代器接口
    1. **begin()**：返回 start，当前有效数据域起始地址；
    2. **end()**：返回 finish，当前有效数据域终止位置（最后一个有效元素后面的位置，这是一个哨兵位）；
3. 容器状态接口（成员函数）
    1. **size()** ：返回的是 `size_type(end()-begin())`，即当前容器中有效数据个数；
    2. **capacity()** ：返回的是 `size_type(end_of_storage-begin())`，即当前容器可以容纳的总元素个数；
    3. **bool empty()** ：若当前容器内没有有效数据，则返回 false，否则返回 true；
    4. **front()** ：返回的是第一个元素，`return *begin();`
    5. **back()** ：返回的是最后一个有效元素，`return *(end()-1);`，再次验证了之前的 end() 是哨兵位；
4. 元素操作接口（成员函数）
    1. **push_back()**：如果还有剩余空间，直接调用全局的 construct(finish,value)，在原本的 finish 位置上构建新的元素，然后 ++finish；
    2. **void pop_back()** ：其内部实现为`--finish;destroy(finish);`直接丢弃，并没有返回最后一个元素，所以在调用 `pop_back()` 之前，要是想得到最后一个元素值，应该先调用 `back()`。
    3. **erase()** ：iterator erase(iterator first, iterator last);该接口清除 \[first,last\) 之间的数据，并调整 finish 的位置。最后返回的是 first 的值。erase 也可以接收一个参数，只擦除指定位置的元素。
    4. **clean()** ：erase(start,finish)；清空容器中的所有元素。
    5. **insert()** ：void insert(iterator position,size_type n, T& value); 在 position 位置插入 n 个元素，每个元素都初始化为值 value。这期间可能会涉及到内存的扩展，见下一节。

### 动态内存管理：

一个容器，从无到有的整个过程中，可能使用到的接口以及**规则**如下：

1. 对于**新内存的请求**，都是调用空间配置器的内存配置接口 `allocate()`;
2. 对于**未初始化的，已请求的内存块**，调用的是 `uninitialized_XXX` 簇函数。其中，将现有数据拷贝到未初始化内存，使用的是 `uninitialized_copy(first,last,result)`；给一个未初始化内存区间填充相同的元素，调用接口 `uninitialized_fill(first,last,value)`，或者是给一个起始位置，只填充 n 个元素，则调用 `uninitialized_fill_n(first,n,value)`。
3. 对于 **已初始化的内存块**，调用 STL 上层的算法，使用 `copy(first,last,result)` 拷贝数据；使用 `fill(first,last,value)` 填充数据。
4. 对于**单个元素**，使用全局的 `construct(position,value)` 来初始化内存。

现假设需要插入 n 个元素（push_back() or insert()），n > 0，**有关内存分配的过程**如下：

1. 判断当前的剩余空间(`(capacity()-size()) ? n`)是否足够容纳，如果是则直接插入即可。（插入过程根据上面的四点规则选择调用接口）；如果不足以容纳，转到第二步。
2. 剩余空间不够，则需要申请新的更大的内存空间，如果是 push_back(),则新的大小是原大小的两倍，`old_size = size();new_size = old_size==0 ? 1:2*old_size; ` ，如果是 insert()，则新的大小为 `new_size = old_size==0 ? 1:old_size + max(old_size,n);`。分配好内存之后就开始拷贝数据，由于新的内存是没有被初始化的，所以可以调用 `uninitialized_copy(start,finish,new_start)`；最后将原空间归还给系统，`destroy(begin(),end());deallocate()`。

## list

### list节点数据结构

```c++
template<typename T>
struct __list_node{
    typedef void* void_pointer;
    void_pointer prev;
    void_pointer next;
    T data;
}
```

从节点结构看，这是一个双向链表。**list 和 vector 都是数据结构，其实我们实际做运算的还是保存在里面的数据，所以当我们从 list 中取一个节点出来的时候，得到的应该是他的 data ，记住这一点很重要！** 后面在涉及到关于迭代器的时候，这个概念就会帮助理解设计原理。

### list迭代器

首先有一点，一个迭代器实例指代的一定是容器的某一个元素，所以在 list 中，一个迭代器一定包含一个 __list_node 节点，或者是有一个指向 __list_node 的指针成员。考虑到迭代器在遍历的过程中能够轻便的制定另一个容器元素，所以使用指向 __list_node 的指针成员来指定当前迭代器所代表的容器元素。

与 vector 不同， list 并非是一片连续内存，所以常规指针并无法满足迭代器的要求（vector 的迭代器是常规指针 void*），所以需要设计一个 __list_iterator 类来实现迭代器的常规操作。

```c++
template<typename T, typename Ref, typename Ptr>
struct __list_iterator{
    using iterator = __list_iterator<T,T&,T*>;
    using self     = __list_iterator<T,Ref,Ptr>;

    using iterator_category = bidirectional_iterator_tag;
    ...     //(nested type def)
    using link_type = __list_node<T> *;

    link_type node;

    //构造函数
    __list_iterator(link_type x):node(x){};
    __list_iterator(){};
    __list_iterator(const iterator& x):node(x.node){};

    //运算符重载
    bool operator==(const self& x) const {return node == x.node;}
    bool operator!=(const self& x) const {return node != x.node;}
    //递增递减
    self& operator++(){
        node = (link_type)((*node).next);
        return *this;
    }
    self operator++(int){
        self temp(*this);
        ++(*this);
        return temp;
    }
    self& operator--(){
        node = (link_type)((*node).prev);
        return *this;
    }
    self operator--(int){
        self temp(*this);
        --(*this);
        return temp;
    }
    //解引用
    reference operator*() const {return (*node).data;}
    pointer operator->() const {return &(operator*());}
}
```

说明：

1. `operator++()` 定义了前置自加运算符，所以在后置自加运算符(`operator++(int)`)的定义中使用的是重载了的 `operator++()` 运算符。自减运算符同理。
2. 关于自加和自减运算符的返回值类型，前置运算返回值类型为引用，是因为自加之后使用的就是返回的结果；后置运算返回值类型是按值传递的，再结合拷贝构造函数，是浅复制，所以返回了一个指向前一个容器元素的迭代器，也正是因为是浅复制，所以其实可以看做就是前一个迭代器本身。
3. 有关于解引用部分，回想之前说的，**当我们从 list 中取一个节点出来的时候，得到的应该是他的 data ，记住这一点很重要！** 对一个迭代器解引用，得到的应该是它所指代的容器元素的数据，所以相当于 `data_type * iterator;` 迭代器类型是一个数据的指针类型，那么 `iterator->` 相当于 `(&data)->` ，所以 `operator*()` 解引用运算符返回的结果是 `(*node).data;` 返回的是 data 本身，而 `operator->()` 返回的是 `&(operator*())` ，相当于返回的是 `&data` 。这里的 `operator*()` 就是已经被重载的解引用运算符。

### list 结构

list 不仅是一个双向链表，还是一个环形链表，所以仅使用一个节点指针就可以表示整个 list 了，为了适配 STL 的左闭右开区间规则，把这个起始节点置为空节点，而他的 next 才是整个 list 的 begin();