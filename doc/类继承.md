# 类继承

当一个类是从另一个类继承而来的，那么新的类被称为派生类，而原来已有的类被称为基类。

## 公有派生

```c++
class DerivedClass : public BaseClass{
    ...
}
```

继承的部分有：

1. 基类的公有成员会成为派生类的公有成员；
2. 基类的私有部分也将成为派生类的一部分，但是只能通过基类的公有和保护方法去访问。

派生类需要做的事情：

1. 派生类需要编写自己的构造函数；
2. 派生类可以根据需要添加数据成员和成员方法。

### 关于公有派生的构造函数

**注意：** 派生类的构造函数需要为基类的数据成员提供数据。

一个派生类的执行过程如下：

1. 创建一个新的派生类对象的时候先调用基类构造函数来初始化一个基类对象；
2. 进入派生类构造函数代码段，初始化新添加的类数据成员（如果有的话）。

```c++
//构造函数 1
DerivedClass::DerivedClass(int new_member,BaseClass &base_item)
{
    m_newmember = new_member;
}
//构造函数 2
DerivedClass::DerivedClass(int new_member,int base_member1, string base_member2):BaseClass(base_member1,base_member2)
{
    m_newmember = new_member;
}
//构造函数 3
DerivedClass::DerivedClass(int new_member,BaseClass &base_item):BaseClass(base_item)
{
    m_newmember = new_member;
}
```
上述代码中的第一种派生类构造函数，由于没有指定如何初始化基类成员，所以与下述代码等效：
```c++
DerivedClass::DerivedClass(int new_member,BaseClass &base_item)：BaseClass()
{
    m_newmember = new_member;
}
```
相当于我们在声明一个基类对象的时候没有进行初始化，这样的话，这个基类对象就会调用默认构造函数，那么实际上传入的 base_memberX 就没有被使用。

对于第二种派生类构造函数，指定了调用这样的基类构造函数来给基类对象初始化，但是这种方式的前提是基类实现了这样的构造函数。

第三种派生类构造函数是通过一个基类对象来进行初始化工作，从之前所学可知，这是类的复制构造函数，如果基类没有显式实现这种构造函数，那么编译器再用到的时候会自动生成一个浅拷贝版本的复制构造函数。

所以综上所述，一个派生类的构造函数在进入自己的逻辑之前一定会调用一个基类的构造函数，先初始化一个基类对象，然后再进入自己的逻辑里面初始化新添加的数据成员（如果有的话）。所以如果要析构一个派生类对象，析构的顺序是和构造的顺序相反的，首先会调用派生类的析构函数，然后再自动调用基类的析构函数。

有一点需要注意的是，一个派生类仅仅只能将数据传递给其相邻的基类。

```c++
class A{};
class B:public A{};
class C:public B{}'
```

对于上述情况，C 类的构造函数仅能将数据信息传递给类 B，而不能传递给类 A，不过类 B 可以将得到的信息继续向后传递给类 A 。

### 派生类和基类之间的关系

1. 派生类可以使用基类的方法，但是前提是这个方法不能是私有的；
2. 基类指针可以在不显式类型转换的情况下指向派生对象；
3. 基类引用可以在不显式类型转换的情况下引用派生对象。

不过基类的指针或者引用只能调用基类的方法，并且指向派生类的指针或者是派生类的引用是不能指向或者引用基类对象的（因为基类对象没有派生类的方法）。所以可以使用一个派生类对象来初始化一个基类对象：

```c++
DerivedClass devired_item;
BaseClass base_item(devired_item);
```

对于上述的代码，第二句对应的函数原型应该是

```c++
BaseClass::BaseClass(DerivedClass &);
```

实际上在设计类 BaseClass 的时候是没有这个函数原型的，但是却有复制构造函数原型如下：

```c++
BaseClass::BaseClass(BaseClass &);
```

此时函数原型形参类型为基类引用，而实际传入的实参类型是派生类引用，由于基类引用是可以引用派生类对象的，所以

```c++
BaseClass base_item(devired_item);
```

这句的调用是没有问题的。

同样的如果把一个派生类对象赋值给一个基类对象也是可以的，这个时候调用的就是基类重载的赋值运算符。

## 私有派生

## 小知识点

### 1、 关于成员初始化列表

如果一个类的成员数据是一个对象，由之前的学习可知，在类声明的时候是没有真正分配内存空间的，所以是没有一个真实对象产生的，直到用这个类声明来产生一个真是对象的时候，才会真的给其成员变量分配内存空间，才会产生成员对象。所以如果一个类：

```c++
class Test{
    private:
        Memberclass1 m_item1;
        Memberclass2 m_item2;
        ...
    public:
        Test(Memberclass1 &item1, Memberclass2 &item2);
};
Test::Test(Memberclass1 &item1, Memberclass2 &item2)
{
    m_item1 = item1;
    m_item2 = item2;
}
```

如果构造函数如上所示，那么这个构造函数的调用过程如下：

1. Test 对象的声明语句调用构造函数 Test(Memberclass1 &, Memberclass2 &),但是由于需要先产生一个 MemberclassX 对象用于被赋值，所以在进入该构造函数的左大括号之前首先会调用 MemberclassX 的默认构造函数，生成对象 m_itemX。
2. 然后进入 Test 的构造函数中调用 MemberclassX 的赋值运算符函数，为对象成员变量赋值。

不过如果构造函数是使用**成员初始化列表**的方式来对成员进行初始化的：

```c++
Test::Test(Memberclass1 &item1, Memberclass2 &item2)
:m_item1(item1),m_item2(item2)
{}
```

**那么 Test 构造函数会在进入大括号之前，调用 MemberclassX 的复制构造函数直接初始化 m_itemX 。**
