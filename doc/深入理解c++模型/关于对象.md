# 关于对象

<!-- TOC -->
- [关于对象](#关于对象)
  - [c++ 对象模型](#c-对象模型)
    - [简单对象模型](#简单对象模型)
    - [表格驱动对象模型](#表格驱动对象模型)
    - [c++ 的对象内容](#c-的对象内容)
    - [对象所占用的内存空间](#对象所占用的内存空间)

相比于 c 语言的结构体，c++ 的对象做了方法与数据的封装。但是这种封装并没有带来太多的额外的内存消耗。在程序性的方法中，数据与程序分开，也就是说程序只有一份，数据保存在数据成员中。在面向对象中，虽然将数据与方法都封装在了一起，但是一个类的方法都只有一份，而不论有多少对象，但是每个对象都有自己的数据成员，所以从这点上来看，在内存上，面向对象和程序性编程的消耗是一样的。

上述有一个不严谨的地方，那就是函数的实例个数，对于非内联的函数确实是一个类只有一份程序源码，但是如果是内联的，却是在每个出现的地方都会有一份副本，实际上可以看作是字符替换，但是这也无关紧要，因为这个特性不论是 c 还是 c++ 都是一眼的。

面向对象的封装所带来的额外内存消耗以及存取时间消耗，主要是由 virtual 特性引起的。主要的消耗点后面会详述。

## c++ 对象模型

在 c++ 中，类成员变量分为两类：

1. 静态成员变量
2. 非静态成员变量

类成员方法分为三类：

1. 静态成员方法
2. 非静态成员方法
3. 虚成员方法

一个对象是其类的实例化，因为对象可以调用类方法，所以即使类方法的代码只有一份，但是在对象中仍然需要有手段能够获得类方法的地址，这样类方法才能被调用。换句话说，如何去组织一个对象，需要保存哪些东西，怎么保存，是对象首先需要解决的问题。**对象中成员的组织方式，就是对象模型。**

### 简单对象模型

这种对象模型的对象组织方式是： **一个对象中保存的是所有成员的指针。** 这个对象就像是一个有多个卡槽的板子，每个卡槽插入的都是指针，分别指向每一个成员，包括成员变量和成员函数。按照类声明中成员出现的顺序，依次出现在对象的卡槽中。

对成员变量也是使用指针是为了适应不同内存大小的数据类型。所以简单对象模型的对象大小很好计算，就是对象数目乘以指针大小。这种对象模型是为了减少编译器的设计难度，赔上的空间和执行期的效率。赔上空间是因为对于数据成员，每一个成员都会额外增加一个指针的大小，并且每个对象都保存了类方法的地址。赔上执行期间效率是因为？？？

> 该对象模型并没有应用于实际的产品中。

### 表格驱动对象模型

这种对象模型是将成员数据和成员方法分开了，分别存储于两种表中，其中成员数据表保存的就是成员数据本身，其大小就是成员所占内存大小；成员方法表是与简单对象模型中的卡槽概念相同，有多少成员方法，就有多少个卡槽，大小为成员方法数目乘以指针大小。而对象本身，值保存两个指针，分别指向这两个表。

> 该对象模型也没有应用于实际产品中。

### c++ 的对象内容

每个对象都需要保存自己的所有非静态成员变量，直接保存在对象中。而同一个类的所有的静态成员变量、静态非静态成员方法，都保存在一个地方，一个类只有一份。

对于虚函数而言：

1. 一个类，会产生一张虚表，每一个表项指向的是一个虚函数具体实现的地址。该类会为其内所有的虚函数都分别生成一个指向虚函数的指针，这些指针的值就保存在虚表中。
2. 当这个类生成一个对象的时候，都会在这个对象中多添加一个数据项，就是指向虚表地址的指针。这个指针值的设定、重置，都是由构造函数（只要是构造函数）、析构函数以及赋值运算符来自动处理，并且会在虚表的头部添加一个额外的，非虚函数项，那就是这个类所关联的类型信息对象（type_info object)，这个类型信息对象是用来支持运行时类型识别(RTTI)的，保存在虚表的第一个表项，也就是说虚表的第一个表项并不是指向的虚函数地址，而是一个 type_info object。

上述就是对于非继承对象的对象模型描述，那对于派生类对象而言，如何保存他的基类实例呢？有以下几种方法：

1. 出于对统一表示方法方面的考虑，想象每个类还生成有一张表，这张表保存的是指向该派生类每一个基类实例地址的指针（c++支持多重继承），这样的话，任何一个类对于其基类的描述都是一样的，在对象中多了一个指针，指向这个表，然后通过这张表去获得其基类实例的相关数据。这种方法的缺点是，如果继承链太长，需要获取基类相关数据的时候就会把时间花费在寻址上。但是优点是描述统一，且如果基类修改了（如删除或增加了数据成员），是不会影响派生类对象大小的。
2. 出于存取效率的方面考虑，直接将基类的数据成员保存在继承类对象中，这样就没有了多重的寻址过程，但是缺点就是基类成员的添加或者减少，会影响到派生类成员的大小。

在学习 《c++ primer plus》 的时候，有提到过虚基类，当涉及到虚基类的时候，因为只有一个基类实例，所以这时候就需要通过添加一个虚基类表来实现相关特性，详细内容之后会讲述。

### 对象所占用的内存空间

一个对象，在内存中应该保存的东西一般而言有这些：

1. 非静态数据成员；
2. 为了支持 virtual 而所需要的额外内存负担。

**对于第一点需要注意，涉及到字节对齐的问题，实际占用的内存大小是其要求字节对齐的整数倍。** 而对于程序中的指针，都是固定大小，不论指针类型。

不同类型的指针所占用的内存大小都是一样的，但是却能表示不同的对象，是因为指针类型是可以"教导"编译器，使其在从内存中取数据的时候，知道该取多大，每个"字段"是什么意思。

```c++
class base_class{...};
class derived_class:public base_class{...};
int main(){
    derived_class d;

    base_class *ptr_b = &d;
    derived_calss *ptr_d = &d;

    base_class b = d;
}
```

对于上述的派生类对象 d 而言，他的内存中保存了基类 base_class 子对象，以及自身定义的新的数据成员。基类的指针和派生类的指针都可以指向这个派生类对象，他们现在的值（地址）都相同，但是被编译器解释的结果不同。基类指针所能表示所指对象的范围仅仅是基类子对象能覆盖的范围，通过它并不能调用派生类中的方法或访问派生类中的成员数据。而派生类指针当让可以完全执行对派生类合法的操作。

对于 ptr_b, ptr_d 而言，如果基类中有虚函数，并且该虚函数在派生类中被重新定义了，那么通过指针来调用虚函数，会根据指针实际所指对象来决定调用版本，而不是指针类型，如对于 ptr_b 是一个基类指针，但是如果调用一个虚函数 virtual_func ，实际调用的是 derived_class::virtual_func ，因为他所指的是一个派生类对象。

如果不是通过指针来调用，例如最后的给变量 b 赋值为 d ，此时的 b 会被构造成与 d 的基类子对象相同。通过 b 调用 virtual_func 调用的就是基类版本 base_class::virtual_func 。
