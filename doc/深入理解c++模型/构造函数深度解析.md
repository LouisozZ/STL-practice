# 构造函数深度解析

<!-- TOC -->
- [构造函数深度解析](#构造函数深度解析)
  - [默认构造函数的产生](#默认构造函数的产生)
    - [[1]类定义中有别的类成员对象，且该对象有默认构造函数](#1类定义中有别的类成员对象且该对象有默认构造函数)
    - [[2]一个类继承自带有默认构造函数的基类](#2一个类继承自带有默认构造函数的基类)
    - [[3]一个类中包含了虚函数](#3一个类中包含了虚函数)
    - [[4]一个类带有虚基类](#4一个类带有虚基类)
  - [拷贝构造函数的构造操作](#拷贝构造函数的构造操作)
    - [[1]含有成员对象，且成员对象有拷贝构造函数](#1含有成员对象且成员对象有拷贝构造函数)
    - [[2]继承自一个有拷贝构造函数的基类](#2继承自一个有拷贝构造函数的基类)
    - [[3]类声明中有虚函数](#3类声明中有虚函数)
    - [[4]类派生自一个继承链，其中有虚基类](#4类派生自一个继承链其中有虚基类)

构造函数是用来初始化一个类对象的，构造函数分为默认构造函数、拷贝构造函数、一般构造函数。其中默认构造函数指的是可以不接受任何参数就可以创建对象的构造函数（或者构造函数原型的参数列表为空，或者都有默认值，一个类只能有一个默认构造函数）；拷贝构造函数是声明一个类的时候用另一个合法类对象赋值时候调用的构造函数；一般构造函数就是不符合上面两个构造函数特征的剩余部分。

## 默认构造函数的产生

**如果程序员没有为类编写默认构造函数，编译器有的时候会为其声明默认构造函数，但是切记，是有时候，并不总是。** 由编译器生成的默认构造函数所做的事情仅仅只做了编译器所需要的，比如为一个派生类对象隐式地构造基类子对象，这是编译器需要完成的事情，但是如果是想要为当前类的某个类成员变量初始化为 0 或者其他，这个就不是编译器需要的，而是程序需要的，这个就需要程序员自己来负责。

之所以说编译器有时候会而有时候不会自动生成默认构造函数，是因为生成默认构造函数是需要一定条件的。以下是 c++95 标准关于默认构造函数的一段描述：

> 对一个类，类定义中如果没有任何用户定义的构造函数，那么编译器会为其生成一个隐式默认构造函数，该函数是没有任何用处的。

所谓没有任何用处就是这个构造函数不做任何实际的事情，也就是在学习 [stl 空间配置器](../stl学习/空间分配器)的时候所提到 has_trivial_default_constructor 为 __true_type 。但是编译器在以下四种情况下，会自动生成有用的默认构造函数：

### [1]类定义中有别的类成员对象，且该对象有默认构造函数

```c++
class AClass{
    public:
        AClass(){...}
    ...
};
class BClass{
    AClass m_obj;
    int m_data;
};

class CClass{
    AClass m_obj;
    int m_data;
    public:
        CClass(){...}
    ...
};
```

在上述的代码块中，AClass 是一个带有默认构造函数的类， BClass 和 CClass 的类定义中都有一个 AClass 类型的成员 m_obj，但是他们的不同之处在于， BClass 没有显示定义默认构造函数，而 CClass 定义了默认构造函数。

对于 BClass 而言，首先因为他没有默认构造函数，所以编译器可以为其自动生成一个，并且由于其中有一个带有默认构造函数的成员对象 m_obj，所以编译器为其生成的默认构造函数是有用的，即 has_trivial_default_constructor 为 __false_type 。生成的默认构造函数内部只是调用了 AClass()，而并未处理 m_data，这就是编译器生成的默认构造寒素只做了编译器需要的做的事情。

对于 CClass 而言，因为程序员已经显示定义了默认构造函数，所以编译器没有办法再生成一个默认构造函数，这个时候编译器做的事情就是扩展已存在的每个构造函数，在已有的构造函数基础上添加代码，调用成员对象的默认构造函数，调用的时机相当于构造函数的成员初始化列表。这里需要注意，这种情况下编译器被没有生成新的构造函数，而是在原有构造函数的基础上进行的扩展。

给出的代码例子中只有一个成员对象，如果有多个，那么对依次调用他们的默认构造函数，调用顺序就是他们在类定义中的声明顺序。

### [2]一个类继承自带有默认构造函数的基类

```c++
class AClass{
    public:
        AClass(){...}
    ...
};
class CClass{
    AClass m_obj;
    int m_data;
    public:
        CClass(){...}
    ...
};
class BClass：public AClass{
    CClass m_obj;
    int m_data;
};
```

上述代码中，AClass 是基类，带有默认构造函数，BClass 继承自 AClass，所以编译器会为其生成隐式默认构造函数，这个构造函数会调用基类的默认构造函数。

如果派生类已经定义了构造函数，那么编译器同样也是对现有构造函数进行扩展，不会生成新的构造函数，若，派生类中还有带有默认构造函数的成员对象，那么是基类的默认构造函数先于成员对象的默认构造函数被调用。

### [3]一个类中包含了虚函数

这个包含不仅指定义了虚函数，同时也指继承了虚函数的情况，并且如果这个类是派生自某一个继承串链，其中有一个或多个虚基类，这种情况下编译器也会为他们生成默认构造函数。

首先来看关于虚函数，编译器是怎么来处理的。

```c++
class baseclass{
    public:
        virtual void func() = 0;
    ...
};
class Derived1:public baseclass{...};
class Derived2:public baseclass{...};

void invok_func(baseclass& obj){obj.func();}

void test(){
    Derived1 a;
    Derived2 b;

    invok_func(a);
    invok_func(b);
}
```

在上述代码中，不到运行时，并不知道 obj 的实际类型，所以没有办法确定是调用 baseclass、Derived1 还是 Derived2 那个版本的实现，这就需要通过一个叫做虚函数表（virtual function table）的东西来辅助实现，这个表一个类有一张，里面存放的就是这个类里面每个虚函数对应的实际实现地址，该表由编译器生成；当要产生对象的时候，编译器会增加一个成员到对象之中，这个成员就是虚表指针 vptr ，指向该对象类的虚表。

有了上述的辅助数据之后，函数 invok_func 的实现可能会被编译器改变成如下样子：

```c++
void invok_func(baseclass& obj){(*obj.vptr[1])(&obj);}
```

这里的通过虚表取得所调用虚函数的地址，因为这是一个成员函数，所以需要将 &obj 作为参数传入，也就是传入 this 指针。虚表中的 1 表示的是虚函数 func() 在虚表中的固定索引。

上述就是一个虚函数调用的数据准备与调用过程，为了支持这样的过程，所以当一个对象被构造的时候就应该产生一个虚表指针，指向一个有效的虚表地址。因此就需要编译器做这些额外的工作，所以就需要扩展每一个构造函数来完成这样的事情，当一个类没有构造函数被程序员显式定义的时候，理所当然的，编译器就应该生成一个默认构造函数完成上述工作。

### [4]一个类带有虚基类

在 [关于对象](./关于对象.md)一文中之前有所提到，派生类中的基类子对象是可以直接保存在派生类对象中，所以对于一个基类公有成员的访问可以直接通过偏移来实现。

虚基类的特点是，在继承链中，如果一个基类被多次虚继承，最后也只会存在一个实例。

结合上述两点，在一个继承链中，需要定位（得到偏移）这个基类子对象的工作就会变得困难，因为类型不同，基类子对象的偏移就可能会不同。

```c++
class X{public: int m_x;};
class A:virtual public X{public: int m_a;};
class B:virtual public X{public: int m_b;};
class C:public A,public B{public: int m_c;};

void func(A* item){std::cout << item->m_x << std::endl;}

int main(){
    func(new A);
    func(new C);
}
```

m_x 变量在类 A 和类 C 中的偏移就是不同的，所以要想函数 func 能够正确执行，就需要在运行期之前，能够确定到虚基类中成员的偏移，或者说能够正确访问到。

实现方法有很多，其中一种就是在派生类对象中添加一个指针成员，指向这个虚基类，然后通过这个指针来访问虚基类成员，那么对于 `item->m_x` 的访问就可能变成 `item->vbcX->m_x` ，其中的 vbcX 就是一个指向虚基类 X 的指针。显然，这个指针的值是需要编译器来完成赋值与添加到派生类对象中，所以跟虚函数的方法类似，编译器或扩展所有已经存在的构造函数，添加以上相关代码，如果没有定义构造函数，那么编译器会自动生成一个隐式的默认构造函数。

## 拷贝构造函数的构造操作

什么情况下会调用拷贝构造函数？

1. 当显式的用一个同类型的对象来初始化一个新对象的时候；

    ```c++
    class A{...};
    A origin;   //调用默认构造函数
    A current = origin;     // 构造 current 的时候调用拷贝构造
    ```

2. 当按值传递对象给一个函数的时候；

    ```c++
    void function(A obj){...}
    int main(){A item; function(item);}  
    //调用拷贝构造函数，使用 item 来初始化 obj
    ```

3. 当返回值类型是一个类的时候；

    ```c++
    A function2(int i, int j){ A temp(i,j);return temp;}
    //调用拷贝构造函数来初始化函数 function2 的返回值
    ```

首先有一点可以明确，对于非自定义类型的成员，由编译器生成的拷贝构造函数只做浅拷贝，而对于自定义类型的成员，编译器会添加调用成员对象的拷贝构造函数的代码（不论成员对象的拷贝构造函数是编译器生成还是程序员手动定义），递归对成员对象调用各自的拷贝构造函数。如果成员对象没有拷贝构造函数，那么就是递归地对每个成员对象进行浅拷贝，直接赋值。

如果一个类中的所有成员都是内建类型，那么编译器可能并不会产生实际的拷贝构造函数，而是通过直接赋值来完成拷贝工作，但是上述的过程，从概念上来说，是通过拷贝构造函数来完成的。意思就是，没有实际的函数调用，整个过程就是赋值，不过这个过程叫做调用了拷贝构造函数。

但是如果有成员对象，并且该对象有自己的拷贝构造函数，那么外层的这个类就需要编译器生成默认拷贝构造函数来进行成员对象的拷贝构造函数调用了。这只是一种情况，一共有四种情况，编译器必须为一个类生成默认拷贝构造函数，或者是为已有的拷贝构造函数添加额外代码。

### [1]含有成员对象，且成员对象有拷贝构造函数

这就是上面提到的情况，需要通过调用成员对象的拷贝构造函数来对该成员对象进行拷贝，这一点仅仅通过赋值是做不到的(当然，这里不涉及重载了赋值运算符，而仅仅是讨论什么时候编译器必须生成拷贝构造函数)。

### [2]继承自一个有拷贝构造函数的基类

这种情况与第一种情况相同，都需要一个函数调用来完成基类子对象的拷贝工作。

### [3]类声明中有虚函数

这种情况下跟默认构造函数必须被编译器生成出来的原理是一样的，因为左值不能直接使用右值的 vptr 值，因为如果左值是基类，而右值是派生类，这样的话直接将虚表的值赋过去就会出错，所以需要编译器生成拷贝构造函数，在函数内部，指定正确的虚表地址，保证程序执行的正确性。

### [4]类派生自一个继承链，其中有虚基类

这种情况也是跟默认构造函数的情况相同，需要编译器生成一个拷贝构造函数来保证关于虚基类的偏移是正确的。
